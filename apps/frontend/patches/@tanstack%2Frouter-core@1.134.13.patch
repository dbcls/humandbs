diff --git a/dist/cjs/path.cjs b/dist/cjs/path.cjs
index 10145c5f76f58fa7673a6f61090860422107397c..c3a96b266703aaba0d430c782a5bca940fc92eec 100644
--- a/dist/cjs/path.cjs
+++ b/dist/cjs/path.cjs
@@ -72,11 +72,15 @@ function segmentToString(segment) {
   return value;
 }
 function resolvePath({
+  basepath,
   base,
   to,
   trailingSlash = "never",
+  caseSensitive,
   parseCache
 }) {
+  base = removeBasepath(basepath, base, caseSensitive);
+  to = removeBasepath(basepath, to, caseSensitive);
   let baseSegments = parsePathname(base, parseCache).slice();
   const toSegments = parsePathname(to, parseCache);
   if (baseSegments.length > 1 && utils.last(baseSegments)?.value === "/") {
@@ -108,7 +112,7 @@ function resolvePath({
     }
   }
   const segmentValues = baseSegments.map(segmentToString);
-  const joined = joinPaths(segmentValues);
+  const joined = joinPaths([basepath, ...segmentValues]);
   return joined;
 }
 const parsePathname = (pathname, cache) => {
@@ -140,7 +144,8 @@ function baseParsePathname(pathname) {
   const split = pathname.split("/").filter(Boolean);
   segments.push(
     ...split.map((part) => {
-      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);
+      const partToMatch = part.slice(-1) === "_" ? part.slice(0, -1) : part;
+      const wildcardBracesMatch = partToMatch.match(WILDCARD_W_CURLY_BRACES_RE);
       if (wildcardBracesMatch) {
         const prefix = wildcardBracesMatch[1];
         const suffix = wildcardBracesMatch[2];
@@ -151,7 +156,7 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      const optionalParamBracesMatch = part.match(
+      const optionalParamBracesMatch = partToMatch.match(
         OPTIONAL_PARAM_W_CURLY_BRACES_RE
       );
       if (optionalParamBracesMatch) {
@@ -166,7 +171,7 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);
+      const paramBracesMatch = partToMatch.match(PARAM_W_CURLY_BRACES_RE);
       if (paramBracesMatch) {
         const prefix = paramBracesMatch[1];
         const paramName = paramBracesMatch[2];
@@ -178,8 +183,8 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      if (PARAM_RE.test(part)) {
-        const paramName = part.substring(1);
+      if (PARAM_RE.test(partToMatch)) {
+        const paramName = partToMatch.substring(1);
         return {
           type: SEGMENT_TYPE_PARAM,
           value: "$" + paramName,
@@ -187,7 +192,7 @@ function baseParsePathname(pathname) {
           suffixSegment: void 0
         };
       }
-      if (WILDCARD_RE.test(part)) {
+      if (WILDCARD_RE.test(partToMatch)) {
         return {
           type: SEGMENT_TYPE_WILDCARD,
           value: "$",
@@ -197,7 +202,7 @@ function baseParsePathname(pathname) {
       }
       return {
         type: SEGMENT_TYPE_PATHNAME,
-        value: part
+        value: partToMatch.includes("%25") ? partToMatch.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(partToMatch)
       };
     })
   );
@@ -240,7 +245,7 @@ function interpolatePath({
         usedParams["*"] = params._splat;
         const segmentPrefix = segment.prefixSegment || "";
         const segmentSuffix = segment.suffixSegment || "";
-        if (!params._splat) {
+        if (!("_splat" in params)) {
           isMissingParams = true;
           if (leaveWildcards) {
             return `${segmentPrefix}${segment.value}${segmentSuffix}`;
@@ -307,25 +312,63 @@ function encodePathParam(value, decodeCharMap) {
   }
   return encoded;
 }
-function matchPathname(currentPathname, matchLocation, parseCache) {
-  const pathParams = matchByPath(currentPathname, matchLocation, parseCache);
+function matchPathname(basepath, currentPathname, matchLocation, parseCache) {
+  const pathParams = matchByPath(
+    basepath,
+    currentPathname,
+    matchLocation,
+    parseCache
+  );
   if (matchLocation.to && !pathParams) {
     return;
   }
   return pathParams ?? {};
 }
-function matchByPath(from, {
+function removeBasepath(basepath, pathname, caseSensitive = false) {
+  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase();
+  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
+  switch (true) {
+    // default behaviour is to serve app from the root - pathname
+    // left untouched
+    case normalizedBasepath === "/":
+      return pathname;
+    // shortcut for removing the basepath if it matches the pathname
+    case normalizedPathname === normalizedBasepath:
+      return "";
+    // in case pathname is shorter than basepath - there is
+    // nothing to remove
+    case pathname.length < basepath.length:
+      return pathname;
+    // avoid matching partial segments - strict equality handled
+    // earlier, otherwise, basepath separated from pathname with
+    // separator, therefore lack of separator means partial
+    // segment match (`/app` should not match `/application`)
+    case normalizedPathname[normalizedBasepath.length] !== "/":
+      return pathname;
+    // remove the basepath from the pathname if it starts with it
+    case normalizedPathname.startsWith(normalizedBasepath):
+      return pathname.slice(basepath.length);
+    // otherwise, return the pathname as is
+    default:
+      return pathname;
+  }
+}
+function matchByPath(basepath, from, {
   to,
   fuzzy,
   caseSensitive
 }, parseCache) {
-  const stringTo = to;
+  if (basepath !== "/" && !from.startsWith(basepath)) {
+    return void 0;
+  }
+  from = removeBasepath(basepath, from, caseSensitive);
+  to = removeBasepath(basepath, `${to ?? "$"}`, caseSensitive);
   const baseSegments = parsePathname(
     from.startsWith("/") ? from : `/${from}`,
     parseCache
   );
   const routeSegments = parsePathname(
-    stringTo.startsWith("/") ? stringTo : `/${stringTo}`,
+    to.startsWith("/") ? to : `/${to}`,
     parseCache
   );
   const params = {};
@@ -341,6 +384,10 @@ function matchByPath(from, {
 function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
   let baseIndex = 0;
   let routeIndex = 0;
+  let processedOptionals = 0;
+  const optionalCount = routeSegments.filter(
+    (seg) => seg.type === SEGMENT_TYPE_OPTIONAL_PARAM
+  ).length;
   while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {
     const baseSegment = baseSegments[baseIndex];
     const routeSegment = routeSegments[routeIndex];
@@ -446,10 +493,12 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
       }
       if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
         if (!baseSegment) {
+          processedOptionals++;
           routeIndex++;
           continue;
         }
         if (baseSegment.value === "/") {
+          processedOptionals++;
           routeIndex++;
           continue;
         }
@@ -475,18 +524,50 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
           }
         } else {
           let shouldMatchOptional = true;
+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0;
+          const remainingRouteSegmentLength = (routeSegments.slice(-1)[0]?.value === "/" ? routeSegments.length - 1 : routeSegments.length) - routeIndex;
+          const remainingRequiredRouteSegmentCount = remainingRouteSegmentLength - (optionalCount - processedOptionals);
+          const remainingBaseSegmentCount = baseSegments.length - baseIndex;
           for (let lookAhead = routeIndex + 1; lookAhead < routeSegments.length; lookAhead++) {
             const futureRouteSegment = routeSegments[lookAhead];
-            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME && futureRouteSegment.value === baseSegment.value) {
-              shouldMatchOptional = false;
+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {
+              if (caseSensitive ? futureRouteSegment.value === baseSegment.value : futureRouteSegment.value.toLowerCase() === baseSegment.value.toLowerCase()) {
+                shouldMatchOptional = false;
+              }
               break;
             }
-            if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {
-              if (baseSegments.length < routeSegments.length) {
+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
+              if (remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount) {
                 shouldMatchOptional = false;
               }
               break;
             }
+            if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {
+              const followingRouteSegment = routeSegments[lookAhead + 1];
+              let isMatchedFurtherDown = false;
+              if (remainingOptionals && followingRouteSegment && (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME || followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM && (followingRouteSegment.prefixSegment || followingRouteSegment.suffixSegment))) {
+                const remainingRouteSegments = routeSegments.slice(
+                  lookAhead + 1
+                );
+                const remainingRouteSegmentLength2 = remainingRouteSegments.slice(-1)[0]?.value === "/" ? remainingRouteSegments.length - 1 : remainingRouteSegments.length;
+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1);
+                isMatchedFurtherDown = remainingRouteSegmentLength2 === remainingBaseSegments.length && isMatch(
+                  remainingBaseSegments,
+                  remainingRouteSegments,
+                  { ...params },
+                  fuzzy,
+                  caseSensitive
+                );
+              }
+              if (!remainingOptionals || // remaining required segments equals remaining base segments
+              remainingRequiredRouteSegmentCount === remainingBaseSegmentCount || // matched by probe further down
+              isMatchedFurtherDown) {
+                if (remainingBaseSegmentCount < remainingRouteSegmentLength) {
+                  shouldMatchOptional = false;
+                }
+                break;
+              }
+            }
           }
           if (shouldMatchOptional) {
             _paramValue = decodeURIComponent(baseSegment.value);
@@ -497,6 +578,7 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
           params[routeSegment.value.substring(1)] = _paramValue;
           baseIndex++;
         }
+        processedOptionals++;
         routeIndex++;
         continue;
       }
@@ -530,6 +612,7 @@ exports.joinPaths = joinPaths;
 exports.matchByPath = matchByPath;
 exports.matchPathname = matchPathname;
 exports.parsePathname = parsePathname;
+exports.removeBasepath = removeBasepath;
 exports.removeTrailingSlash = removeTrailingSlash;
 exports.resolvePath = resolvePath;
 exports.trimPath = trimPath;
diff --git a/dist/cjs/path.cjs.map b/dist/cjs/path.cjs.map
index ca42c4d8b9fa567a5912111c647c6688fa64b3d3..305d2f290034460c6d111a88adcc941dc7d2a13b 100644
--- a/dist/cjs/path.cjs.map
+++ b/dist/cjs/path.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"path.cjs","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { LRUCache } from './lru-cache'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport interface Segment {\n  readonly type:\n    | typeof SEGMENT_TYPE_PATHNAME\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  readonly value: string\n  readonly prefixSegment?: string\n  readonly suffixSegment?: string\n  // Indicates if there is a static segment after this required/optional param\n  readonly hasStaticAfter?: boolean\n}\n\n/** Join path segments, cleaning duplicate slashes between parts. */\n/** Join path segments, cleaning duplicate slashes between parts. */\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\n/** Remove repeated slashes from a path string. */\n/** Remove repeated slashes from a path string. */\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\n/** Trim leading slashes (except preserving root '/'). */\n/** Trim leading slashes (except preserving root '/'). */\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\n/** Trim trailing slashes (except preserving root '/'). */\n/** Trim trailing slashes (except preserving root '/'). */\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\n/** Trim both leading and trailing slashes. */\n/** Trim both leading and trailing slashes. */\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\n/** Remove a trailing slash from value when appropriate for comparisons. */\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  parseCache?: ParsePathnameCache\n}\n\nfunction segmentToString(segment: Segment): string {\n  const { type, value } = segment\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value\n  }\n\n  const { prefixSegment, suffixSegment } = segment\n\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`\n    }\n  }\n\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`\n    }\n    return `{-$${param}}`\n  }\n\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`\n    }\n  }\n\n  // This case should never happen, should we throw instead?\n  return value\n}\n\n/**\n * Resolve a destination path against a base, honoring trailing-slash policy\n * and supporting relative segments (`.`/`..`) and absolute `to` values.\n */\nexport function resolvePath({\n  base,\n  to,\n  trailingSlash = 'never',\n  parseCache,\n}: ResolvePathOptions) {\n  let baseSegments = parsePathname(base, parseCache).slice()\n  const toSegments = parsePathname(to, parseCache)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index]!\n    const value = toSegment.value\n    if (value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (value === '..') {\n      baseSegments.pop()\n    } else if (value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)!.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map(segmentToString)\n  // const joined = joinPaths([basepath, ...segmentValues])\n  const joined = joinPaths(segmentValues)\n  return joined\n}\n\nexport type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>\n\n/**\n * Parse a pathname into an array of typed segments used by the router's\n * matcher. Results are optionally cached via an LRU cache.\n */\n/**\n * Parse a pathname into an array of typed segments used by the router's\n * matcher. Results are optionally cached via an LRU cache.\n */\nexport const parsePathname = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => {\n  if (!pathname) return []\n  const cached = cache?.get(pathname)\n  if (cached) return cached\n  const parsed = baseParsePathname(pathname)\n  cache?.set(pathname, parsed)\n  return parsed\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{-$paramName}suffix\n\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Optional param: `/foo/{-$bar}`\n * Optional param with Prefix and Suffix: `/foo/prefix{-$bar}suffix`\n\n * Future:\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nfunction baseParsePathname(pathname: string): ReadonlyArray<Segment> {\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for optional parameter format: prefix{-$paramName}suffix\n      const optionalParamBracesMatch = part.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE,\n      )\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1]\n        const paramName = optionalParamBracesMatch[2]!\n        const suffix = optionalParamBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName, // Now just $paramName (no prefix)\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(part)) {\n        const paramName = part.substring(1)\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(part)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n  parseCache?: ParsePathnameCache\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\n/**\n * Interpolate params and wildcards into a route path template.\n *\n * - Encodes params safely (configurable allowed characters)\n * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards\n * - Optionally leaves placeholders or wildcards in place\n */\n/**\n * Interpolate params and wildcards into a route path template.\n * Encodes safely and supports optional params and custom decode char maps.\n */\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path, parseCache)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (key === '*' || key === '_splat') {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value\n      }\n\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat\n\n        // TODO: Deprecate *\n        usedParams['*'] = params._splat\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if _splat parameter is missing. _splat could be missing if undefined or an empty string or some other falsy value.\n        if (!params._splat) {\n          isMissingParams = true\n          // For missing splat parameters, just return the prefix and suffix without the wildcard\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`\n          }\n          // If there is a prefix or suffix, return them joined, otherwise omit the segment\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          return undefined\n        }\n\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1)\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if optional parameter is missing or undefined\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`\n          }\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          // If no prefix/suffix, omit the entire segment\n          return undefined\n        }\n\n        usedParams[key] = params[key]\n\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? ''}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\n/**\n * Match a pathname against a route destination and return extracted params\n * or `undefined`. Uses the same parsing as the router for consistency.\n */\n/**\n * Match a pathname against a route destination and return extracted params\n * or `undefined`. Uses the same parsing as the router for consistency.\n */\nexport function matchPathname(\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n  parseCache?: ParsePathnameCache,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(currentPathname, matchLocation, parseCache)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\n/** Low-level matcher that compares two path strings and extracts params. */\n/** Low-level matcher that compares two path strings and extracts params. */\nexport function matchByPath(\n  from: string,\n  {\n    to,\n    fuzzy,\n    caseSensitive,\n  }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n  parseCache?: ParsePathnameCache,\n): Record<string, string> | undefined {\n  const stringTo = to as string\n\n  // Parse the from and to\n  const baseSegments = parsePathname(\n    from.startsWith('/') ? from : `/${from}`,\n    parseCache,\n  )\n  const routeSegments = parsePathname(\n    stringTo.startsWith('/') ? stringTo : `/${stringTo}`,\n    parseCache,\n  )\n\n  const params: Record<string, string> = {}\n\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive,\n  )\n\n  return result ? params : undefined\n}\n\nfunction isMatch(\n  baseSegments: ReadonlyArray<Segment>,\n  routeSegments: ReadonlyArray<Segment>,\n  params: Record<string, string>,\n  fuzzy?: boolean,\n  caseSensitive?: boolean,\n): boolean {\n  let baseIndex = 0\n  let routeIndex = 0\n\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex]\n    const routeSegment = routeSegments[routeIndex]\n\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        // Capture all remaining segments for a wildcard\n        const remainingBaseSegments = baseSegments.slice(baseIndex)\n\n        let _splat: string\n\n        // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false\n\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if ('prefixSegment' in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false\n            }\n          }\n          if ('suffixSegment' in routeSegment) {\n            if (\n              !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n            ) {\n              return false\n            }\n          }\n\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n\n          // Remove the prefix and suffix from the rejoined splat\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length)\n          }\n\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length,\n            )\n          }\n\n          _splat = rejoinedSplat\n        } else {\n          // If no prefix/suffix, just rejoin the remaining segments\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n        }\n\n        // TODO: Deprecate *\n        params['*'] = _splat\n        params['_splat'] = _splat\n        return true\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === '/' && !baseSegment?.value) {\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          } else if (\n            routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()\n          ) {\n            return false\n          }\n          baseIndex++\n          routeIndex++\n          continue\n        } else {\n          return false\n        }\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false\n        }\n\n        if (baseSegment.value === '/') {\n          return false\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false\n          }\n\n          let paramValue = baseValue\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length)\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length)\n          }\n\n          _paramValue = decodeURIComponent(paramValue)\n          matched = true\n        } else {\n          // If no prefix/suffix, just decode the base segment value\n          _paramValue = decodeURIComponent(baseSegment.value)\n          matched = true\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        // Optional parameters can be missing - don't fail the match\n        if (!baseSegment) {\n          // No base segment for optional param - skip this route segment\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment.value === '/') {\n          // Skip slash segments for optional params\n          routeIndex++\n          continue\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this optional param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (\n            (!prefix || baseValue.startsWith(prefix)) &&\n            (!suffix || baseValue.endsWith(suffix))\n          ) {\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n            matched = true\n          }\n        } else {\n          // For optional params without prefix/suffix, we need to check if the current\n          // base segment should match this optional param or a later route segment\n\n          // Look ahead to see if there's a later route segment that matches the current base segment\n          let shouldMatchOptional = true\n          for (\n            let lookAhead = routeIndex + 1;\n            lookAhead < routeSegments.length;\n            lookAhead++\n          ) {\n            const futureRouteSegment = routeSegments[lookAhead]\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n              futureRouteSegment.value === baseSegment.value\n            ) {\n              // The current base segment matches a future pathname segment,\n              // so we should skip this optional parameter\n              shouldMatchOptional = false\n              break\n            }\n\n            // If we encounter a required param or wildcard, stop looking ahead\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n              futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n            ) {\n              if (baseSegments.length < routeSegments.length) {\n                shouldMatchOptional = false\n              }\n              break\n            }\n          }\n\n          if (shouldMatchOptional) {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n            matched = true\n          }\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n    }\n\n    // If we have base segments left but no route segments, it's a fuzzy match\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params['**'] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value),\n      )\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== '/'\n    }\n\n    // If we have route segments left but no base segments, check if remaining are optional\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      // Check if all remaining route segments are optional\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false\n        }\n      }\n      // All remaining are optional, so we can finish\n      break\n    }\n\n    break\n  }\n\n  return true\n}\n"],"names":["last"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"path.cjs","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { LRUCache } from './lru-cache'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport interface Segment {\n  readonly type:\n    | typeof SEGMENT_TYPE_PATHNAME\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  readonly value: string\n  readonly prefixSegment?: string\n  readonly suffixSegment?: string\n  // Indicates if there is a static segment after this required/optional param\n  readonly hasStaticAfter?: boolean\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  caseSensitive?: boolean\n  parseCache?: ParsePathnameCache\n}\n\nfunction segmentToString(segment: Segment): string {\n  const { type, value } = segment\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value\n  }\n\n  const { prefixSegment, suffixSegment } = segment\n\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`\n    }\n  }\n\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`\n    }\n    return `{-$${param}}`\n  }\n\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`\n    }\n  }\n\n  // This case should never happen, should we throw instead?\n  return value\n}\n\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n  caseSensitive,\n  parseCache,\n}: ResolvePathOptions) {\n  base = removeBasepath(basepath, base, caseSensitive)\n  to = removeBasepath(basepath, to, caseSensitive)\n\n  let baseSegments = parsePathname(base, parseCache).slice()\n  const toSegments = parsePathname(to, parseCache)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index]!\n    const value = toSegment.value\n    if (value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (value === '..') {\n      baseSegments.pop()\n    } else if (value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)!.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map(segmentToString)\n  const joined = joinPaths([basepath, ...segmentValues])\n  return joined\n}\n\nexport type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>\nexport const parsePathname = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => {\n  if (!pathname) return []\n  const cached = cache?.get(pathname)\n  if (cached) return cached\n  const parsed = baseParsePathname(pathname)\n  cache?.set(pathname, parsed)\n  return parsed\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{-$paramName}suffix\n\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Optional param: `/foo/{-$bar}`\n * Optional param with Prefix and Suffix: `/foo/prefix{-$bar}suffix`\n\n * Future:\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nfunction baseParsePathname(pathname: string): ReadonlyArray<Segment> {\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // strip tailing underscore for non-nested paths\n      const partToMatch = part.slice(-1) === '_' ? part.slice(0, -1) : part\n\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = partToMatch.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for optional parameter format: prefix{-$paramName}suffix\n      const optionalParamBracesMatch = partToMatch.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE,\n      )\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1]\n        const paramName = optionalParamBracesMatch[2]!\n        const suffix = optionalParamBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName, // Now just $paramName (no prefix)\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = partToMatch.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(partToMatch)) {\n        const paramName = partToMatch.substring(1)\n\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(partToMatch)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: partToMatch.includes('%25')\n          ? partToMatch\n              .split('%25')\n              .map((segment) => decodeURI(segment))\n              .join('%25')\n          : decodeURI(partToMatch),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n  parseCache?: ParsePathnameCache\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path, parseCache)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (key === '*' || key === '_splat') {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value\n      }\n\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat\n\n        // TODO: Deprecate *\n        usedParams['*'] = params._splat\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if _splat parameter is missing\n        if (!('_splat' in params)) {\n          isMissingParams = true\n          // For missing splat parameters, just return the prefix and suffix without the wildcard\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`\n          }\n          // If there is a prefix or suffix, return them joined, otherwise omit the segment\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          return undefined\n        }\n\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1)\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if optional parameter is missing or undefined\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`\n          }\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          // If no prefix/suffix, omit the entire segment\n          return undefined\n        }\n\n        usedParams[key] = params[key]\n\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? ''}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n  parseCache?: ParsePathnameCache,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(\n    basepath,\n    currentPathname,\n    matchLocation,\n    parseCache,\n  )\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(\n  basepath: string,\n  pathname: string,\n  caseSensitive: boolean = false,\n) {\n  // normalize basepath and pathname for case-insensitive comparison if needed\n  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase()\n  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase()\n\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case normalizedBasepath === '/':\n      return pathname\n\n    // shortcut for removing the basepath if it matches the pathname\n    case normalizedPathname === normalizedBasepath:\n      return ''\n\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname\n\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case normalizedPathname[normalizedBasepath.length] !== '/':\n      return pathname\n\n    // remove the basepath from the pathname if it starts with it\n    case normalizedPathname.startsWith(normalizedBasepath):\n      return pathname.slice(basepath.length)\n\n    // otherwise, return the pathname as is\n    default:\n      return pathname\n  }\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  {\n    to,\n    fuzzy,\n    caseSensitive,\n  }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n  parseCache?: ParsePathnameCache,\n): Record<string, string> | undefined {\n  // check basepath first\n  if (basepath !== '/' && !from.startsWith(basepath)) {\n    return undefined\n  }\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from, caseSensitive)\n  // Default to to $ (wildcard)\n  to = removeBasepath(basepath, `${to ?? '$'}`, caseSensitive)\n\n  // Parse the from and to\n  const baseSegments = parsePathname(\n    from.startsWith('/') ? from : `/${from}`,\n    parseCache,\n  )\n  const routeSegments = parsePathname(\n    to.startsWith('/') ? to : `/${to}`,\n    parseCache,\n  )\n\n  const params: Record<string, string> = {}\n\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive,\n  )\n\n  return result ? params : undefined\n}\n\nfunction isMatch(\n  baseSegments: ReadonlyArray<Segment>,\n  routeSegments: ReadonlyArray<Segment>,\n  params: Record<string, string>,\n  fuzzy?: boolean,\n  caseSensitive?: boolean,\n): boolean {\n  let baseIndex = 0\n  let routeIndex = 0\n  let processedOptionals = 0\n\n  const optionalCount = routeSegments.filter(\n    (seg) => seg.type === SEGMENT_TYPE_OPTIONAL_PARAM,\n  ).length\n\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex]\n    const routeSegment = routeSegments[routeIndex]\n\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        // Capture all remaining segments for a wildcard\n        const remainingBaseSegments = baseSegments.slice(baseIndex)\n\n        let _splat: string\n\n        // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false\n\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if ('prefixSegment' in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false\n            }\n          }\n          if ('suffixSegment' in routeSegment) {\n            if (\n              !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n            ) {\n              return false\n            }\n          }\n\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n\n          // Remove the prefix and suffix from the rejoined splat\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length)\n          }\n\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length,\n            )\n          }\n\n          _splat = rejoinedSplat\n        } else {\n          // If no prefix/suffix, just rejoin the remaining segments\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n        }\n\n        // TODO: Deprecate *\n        params['*'] = _splat\n        params['_splat'] = _splat\n        return true\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === '/' && !baseSegment?.value) {\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          } else if (\n            routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()\n          ) {\n            return false\n          }\n          baseIndex++\n          routeIndex++\n          continue\n        } else {\n          return false\n        }\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false\n        }\n\n        if (baseSegment.value === '/') {\n          return false\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false\n          }\n\n          let paramValue = baseValue\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length)\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length)\n          }\n\n          _paramValue = decodeURIComponent(paramValue)\n          matched = true\n        } else {\n          // If no prefix/suffix, just decode the base segment value\n          _paramValue = decodeURIComponent(baseSegment.value)\n          matched = true\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        // Optional parameters can be missing - don't fail the match\n        if (!baseSegment) {\n          // No base segment for optional param - skip this route segment\n          processedOptionals++\n\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment.value === '/') {\n          // Skip slash segments for optional params\n          processedOptionals++\n\n          routeIndex++\n          continue\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this optional param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (\n            (!prefix || baseValue.startsWith(prefix)) &&\n            (!suffix || baseValue.endsWith(suffix))\n          ) {\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n            matched = true\n          }\n        } else {\n          // For optional params without prefix/suffix, we need to check if the current\n          // base segment should match this optional param or a later route segment\n\n          let shouldMatchOptional = true\n          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n\n          // consider last route segment might be index route and any prior optionals that was not matched\n          const remainingRouteSegmentLength =\n            (routeSegments.slice(-1)[0]?.value === '/'\n              ? routeSegments.length - 1\n              : routeSegments.length) - routeIndex\n\n          const remainingRequiredRouteSegmentCount =\n            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n\n          // Look ahead to see if there's a later route segment that matches the current base segment\n          for (\n            let lookAhead = routeIndex + 1;\n            lookAhead < routeSegments.length;\n            lookAhead++\n          ) {\n            const futureRouteSegment = routeSegments[lookAhead]\n\n            // where the next segment is a required path name, we can break early.\n            // either the current base segment matches a future pathname segment,\n            // in which case we should skip this optional parameter,\n            // or the url is invalid\n            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n              if (\n                caseSensitive\n                  ? futureRouteSegment.value === baseSegment.value\n                  : futureRouteSegment.value.toLowerCase() ===\n                    baseSegment.value.toLowerCase()\n              ) {\n                // so we should skip this optional parameter\n                shouldMatchOptional = false\n              }\n              break\n            }\n\n            // where consecutive optional params are used, we can break early.\n            // preference is given to the first optional param\n            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n              if (\n                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n              ) {\n                shouldMatchOptional = false\n              }\n              break\n            }\n\n            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n              futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n            ) {\n              const followingRouteSegment = routeSegments[lookAhead + 1]\n\n              let isMatchedFurtherDown = false\n\n              // since we know there are remaining optionals, we look to the segment following the next.\n              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n              if (\n                remainingOptionals &&\n                followingRouteSegment &&\n                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n                    (followingRouteSegment.prefixSegment ||\n                      followingRouteSegment.suffixSegment)))\n              ) {\n                const remainingRouteSegments = routeSegments.slice(\n                  lookAhead + 1,\n                )\n\n                const remainingRouteSegmentLength =\n                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n                    ? remainingRouteSegments.length - 1\n                    : remainingRouteSegments.length\n\n                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n\n                isMatchedFurtherDown =\n                  remainingRouteSegmentLength ===\n                    remainingBaseSegments.length &&\n                  isMatch(\n                    remainingBaseSegments,\n                    remainingRouteSegments,\n                    { ...params },\n                    fuzzy,\n                    caseSensitive,\n                  )\n              }\n\n              if (\n                !remainingOptionals ||\n                // remaining required segments equals remaining base segments\n                remainingRequiredRouteSegmentCount ===\n                  remainingBaseSegmentCount ||\n                // matched by probe further down\n                isMatchedFurtherDown\n              ) {\n                if (remainingBaseSegmentCount < remainingRouteSegmentLength) {\n                  shouldMatchOptional = false\n                }\n                break\n              }\n            }\n          }\n\n          if (shouldMatchOptional) {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n            matched = true\n          }\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        processedOptionals++\n\n        routeIndex++\n        continue\n      }\n    }\n\n    // If we have base segments left but no route segments, it's a fuzzy match\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params['**'] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value),\n      )\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== '/'\n    }\n\n    // If we have route segments left but no base segments, check if remaining are optional\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      // Check if all remaining route segments are optional\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false\n        }\n      }\n      // All remaining are optional, so we can finish\n      break\n    }\n\n    break\n  }\n\n  return true\n}\n"],"names":["last","remainingRouteSegmentLength"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/cjs/path.d.cts b/dist/cjs/path.d.cts
index 5da0359c7aea88e5744c0e07b7ee9156a9b375e2..8a005049c9b2ebf7366c11d331ac2d0dcd5d4b39 100644
--- a/dist/cjs/path.d.cts
+++ b/dist/cjs/path.d.cts
@@ -12,52 +12,23 @@ export interface Segment {
     readonly suffixSegment?: string;
     readonly hasStaticAfter?: boolean;
 }
-/** Join path segments, cleaning duplicate slashes between parts. */
-/** Join path segments, cleaning duplicate slashes between parts. */
 export declare function joinPaths(paths: Array<string | undefined>): string;
-/** Remove repeated slashes from a path string. */
-/** Remove repeated slashes from a path string. */
 export declare function cleanPath(path: string): string;
-/** Trim leading slashes (except preserving root '/'). */
-/** Trim leading slashes (except preserving root '/'). */
 export declare function trimPathLeft(path: string): string;
-/** Trim trailing slashes (except preserving root '/'). */
-/** Trim trailing slashes (except preserving root '/'). */
 export declare function trimPathRight(path: string): string;
-/** Trim both leading and trailing slashes. */
-/** Trim both leading and trailing slashes. */
 export declare function trimPath(path: string): string;
-/** Remove a trailing slash from value when appropriate for comparisons. */
 export declare function removeTrailingSlash(value: string, basepath: string): string;
-/**
- * Compare two pathnames for exact equality after normalizing trailing slashes
- * relative to the provided `basepath`.
- */
-/**
- * Compare two pathnames for exact equality after normalizing trailing slashes
- * relative to the provided `basepath`.
- */
 export declare function exactPathTest(pathName1: string, pathName2: string, basepath: string): boolean;
 interface ResolvePathOptions {
+    basepath: string;
     base: string;
     to: string;
     trailingSlash?: 'always' | 'never' | 'preserve';
+    caseSensitive?: boolean;
     parseCache?: ParsePathnameCache;
 }
-/**
- * Resolve a destination path against a base, honoring trailing-slash policy
- * and supporting relative segments (`.`/`..`) and absolute `to` values.
- */
-export declare function resolvePath({ base, to, trailingSlash, parseCache, }: ResolvePathOptions): string;
+export declare function resolvePath({ basepath, base, to, trailingSlash, caseSensitive, parseCache, }: ResolvePathOptions): string;
 export type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>;
-/**
- * Parse a pathname into an array of typed segments used by the router's
- * matcher. Results are optionally cached via an LRU cache.
- */
-/**
- * Parse a pathname into an array of typed segments used by the router's
- * matcher. Results are optionally cached via an LRU cache.
- */
 export declare const parsePathname: (pathname?: string, cache?: ParsePathnameCache) => ReadonlyArray<Segment>;
 interface InterpolatePathOptions {
     path?: string;
@@ -72,28 +43,8 @@ type InterPolatePathResult = {
     usedParams: Record<string, unknown>;
     isMissingParams: boolean;
 };
-/**
- * Interpolate params and wildcards into a route path template.
- *
- * - Encodes params safely (configurable allowed characters)
- * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards
- * - Optionally leaves placeholders or wildcards in place
- */
-/**
- * Interpolate params and wildcards into a route path template.
- * Encodes safely and supports optional params and custom decode char maps.
- */
 export declare function interpolatePath({ path, params, leaveWildcards, leaveParams, decodeCharMap, parseCache, }: InterpolatePathOptions): InterPolatePathResult;
-/**
- * Match a pathname against a route destination and return extracted params
- * or `undefined`. Uses the same parsing as the router for consistency.
- */
-/**
- * Match a pathname against a route destination and return extracted params
- * or `undefined`. Uses the same parsing as the router for consistency.
- */
-export declare function matchPathname(currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>, parseCache?: ParsePathnameCache): AnyPathParams | undefined;
-/** Low-level matcher that compares two path strings and extracts params. */
-/** Low-level matcher that compares two path strings and extracts params. */
-export declare function matchByPath(from: string, { to, fuzzy, caseSensitive, }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>, parseCache?: ParsePathnameCache): Record<string, string> | undefined;
+export declare function matchPathname(basepath: string, currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>, parseCache?: ParsePathnameCache): AnyPathParams | undefined;
+export declare function removeBasepath(basepath: string, pathname: string, caseSensitive?: boolean): string;
+export declare function matchByPath(basepath: string, from: string, { to, fuzzy, caseSensitive, }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>, parseCache?: ParsePathnameCache): Record<string, string> | undefined;
 export {};
diff --git a/dist/cjs/router.cjs b/dist/cjs/router.cjs
index ffcc95163efe46fa63c1795375045def15220209..bb8081ca23821caf9b8f4df1dc645182f5135bfc 100644
--- a/dist/cjs/router.cjs
+++ b/dist/cjs/router.cjs
@@ -235,7 +235,8 @@ class RouterCore {
         base: from,
         to: path.cleanPath(path$1),
         trailingSlash: this.options.trailingSlash,
-        parseCache: this.parsePathnameCache
+        parseCache: this.parsePathnameCache,
+        basepath: this.basepath
       });
       return resolvedPath;
     };
@@ -254,6 +255,7 @@ class RouterCore {
     this.parsePathnameCache = lruCache.createLRUCache(1e3);
     this.getMatchedRoutes = (pathname, routePathname) => {
       return getMatchedRoutes({
+        basepath: this.basepath,
         pathname,
         routePathname,
         caseSensitive: this.options.caseSensitive,
@@ -387,6 +389,7 @@ class RouterCore {
           let params = {};
           const foundMask = this.options.routeMasks?.find((d) => {
             const match = path.matchPathname(
+              this.basepath,
               next.pathname,
               {
                 to: d.from,
@@ -905,6 +908,7 @@ class RouterCore {
       const pending = opts?.pending === void 0 ? !this.state.isLoading : opts.pending;
       const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;
       const match = path.matchPathname(
+        this.basepath,
         baseLocation.pathname,
         {
           ...opts,
@@ -1205,6 +1209,7 @@ function validateSearch(validateSearch2, input) {
   return {};
 }
 function getMatchedRoutes({
+  basepath = "/",
   pathname,
   routePathname,
   caseSensitive,
@@ -1217,6 +1222,7 @@ function getMatchedRoutes({
   const trimmedPath = path.trimPathRight(pathname);
   const getMatchedParams = (route) => {
     const result = path.matchPathname(
+      basepath,
       trimmedPath,
       {
         to: route.fullPath,
diff --git a/dist/cjs/router.cjs.map b/dist/cjs/router.cjs.map
index 718d23b6a70a626cf343f65609023c41edd122fd..ff82335acc2ab18a039747b903633d801cb839f3 100644
--- a/dist/cjs/router.cjs.map
+++ b/dist/cjs/router.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"router.cjs","sources":["../../src/router.ts"],"sourcesContent":["import { Store, batch } from '@tanstack/store'\nimport { createBrowserHistory, parseHref } from '@tanstack/history'\nimport {\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  last,\n  replaceEqualDeep,\n} from './utils'\nimport { processRouteTree } from './process-route-tree'\nimport {\n  cleanPath,\n  interpolatePath,\n  matchPathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, redirect } from './redirect'\nimport { createLRUCache } from './lru-cache'\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from './load-matches'\nimport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath,\n} from './rewrite'\nimport type { ParsePathnameCache } from './path'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  Awaitable,\n  Constrain,\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteLike,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest } from './manifest'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\nimport type {\n  AnySerializationAdapter,\n  ValidateSerializableInput,\n} from './ssr/serializer/transformer'\n// import type { AnyRouterConfig } from './config'\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // Lots of things on here like...\n  // router\n  // config\n  // ssr\n}\n\nexport type RegisteredSsr<TRegister = Register> = TRegister extends {\n  ssr: infer TSSR\n}\n  ? TSSR\n  : false\n\nexport type RegisteredRouter<TRegister = Register> = TRegister extends {\n  router: infer TRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type RegisteredConfigType<TRegister, TKey> = TRegister extends {\n  config: infer TConfig\n}\n  ? TConfig extends {\n      '~types': infer TTypes\n    }\n    ? TKey extends keyof TTypes\n      ? TTypes[TKey]\n      : unknown\n    : unknown\n  : unknown\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport type SSROption = boolean | 'data-only'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated = undefined,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `preloadIntentProximity` a route should use if no preloadIntentProximity is provided.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadintentproximity-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-intent-proximity)\n   */\n  defaultPreloadIntentProximity?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * ```\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n\n  additionalContext?: any\n\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => Constrain<\n    TDehydrated,\n    ValidateSerializableInput<Register, TDehydrated>\n  >\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => Awaitable<void>\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  /**\n   * @default false\n   */\n  isShell?: boolean\n\n  /**\n   * @default false\n   */\n  isPrerendering?: boolean\n\n  /**\n   * The default `ssr` a route should use if no `ssr` is provided.\n   *\n   * @default true\n   */\n  defaultSsr?: SSROption\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?:\n    | boolean\n    | ((opts: { location: ParsedLocation }) => boolean)\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n\n  /**\n   * When `true`, disables the global catch boundary that normally wraps all route matches.\n   * This allows unhandled errors to bubble up to top-level error handlers in the browser.\n   *\n   * Useful for testing tools (like Storybook Test Runner), error reporting services,\n   * and debugging scenarios where you want errors to reach the browser's global error handlers.\n   *\n   * @default false\n   */\n  disableGlobalCatchBoundary?: boolean\n\n  serializationAdapters?: ReadonlyArray<AnySerializationAdapter>\n  /**\n   * Configures how the router will rewrite the location between the actual href and the internal href of the router.\n   *\n   * @default undefined\n   * @description You can provide a custom rewrite pair (in/out).\n   * This is useful for shifting data from the origin to the path (for things like subdomain routing), or other advanced use cases.\n   */\n  rewrite?: LocationRewrite\n  origin?: string\n  ssr?: {\n    nonce?: string\n  }\n}\n\nexport type LocationRewrite = {\n  /**\n   * A function that will be called to rewrite the URL before it is interpreted by the router from the history instance.\n   *\n   * @default undefined\n   */\n  input?: LocationRewriteFunction\n  /**\n   * A function that will be called to rewrite the URL before it is committed to the actual history instance from the router.\n   *\n   * @default undefined\n   */\n  output?: LocationRewriteFunction\n}\n\n/**\n * A function that will be called to rewrite the URL.\n *\n * @param url The URL to rewrite.\n * @returns The rewritten URL (as a URL instance or full href string) or undefined if no rewrite is needed.\n */\nexport type LocationRewriteFunction = ({\n  url,\n}: {\n  url: URL\n}) => undefined | string | URL\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: AnyRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  href?: string\n  _fromLocation?: ParsedLocation\n  unsafeRelative?: 'path'\n  _isNavigate?: boolean\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport interface RouterEvents {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context' | 'serializationAdapters' | 'defaultSsr'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n  forcePending?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  locationToParse: HistoryLocation,\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  pathname: string,\n  routePathname: string | undefined,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch?: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<MakeRouteMatchUnion>\n  /**\n   * @deprecated use the following signature instead\n   */\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => void\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSsr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  isDehydrated: () => boolean\n  onRenderFinished: (listener: () => void) => void\n  dehydrate: () => Promise<void>\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string> | false)\n}\n\n// TODO where is this used? can we remove this?\n/**\n * Convert an unknown error into a minimal, serializable object.\n * Includes name and message (and stack in development).\n */\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n\n/** Options for configuring trailing-slash behavior. */\nexport const trailingSlashOptions = {\n  always: 'always',\n  never: 'never',\n  preserve: 'preserve',\n} as const\n\nexport type TrailingSlashOption =\n  (typeof trailingSlashOptions)[keyof typeof trailingSlashOptions]\n\n/**\n * Compute whether path, href or hash changed between previous and current\n * resolved locations in router state.\n */\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\n/**\n * Core, framework-agnostic router engine that powers TanStack Router.\n *\n * Provides navigation, matching, loading, preloading, caching and event APIs\n * used by framework adapters (React/Solid). Prefer framework helpers like\n * `createRouter` in app code.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType\n */\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  rewrite?: LocationRewrite\n  origin?: string\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      self.__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  isShell() {\n    return !!this.options.isShell\n  }\n\n  isPrerendering() {\n    return !!this.options.isPrerendering\n  }\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const prevOptions = this.options\n    const prevBasepath = this.basepath ?? prevOptions?.basepath ?? '/'\n    const basepathWasUnset = this.basepath === undefined\n    const prevRewriteOption = prevOptions?.rewrite\n\n    this.options = {\n      ...prevOptions,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (!this.options.history) {\n        if (!this.isServer) {\n          this.history = createBrowserHistory() as TRouterHistory\n        }\n      } else {\n        this.history = this.options.history\n      }\n    }\n\n    this.origin = this.options.origin\n    if (!this.origin) {\n      if (!this.isServer && window?.origin && window.origin !== 'null') {\n        this.origin = window.origin\n      } else {\n        // fallback for the server, can be overridden by calling router.update({origin}) on the server\n        this.origin = 'http://localhost'\n      }\n    }\n\n    if (this.history) {\n      this.updateLatestLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store && this.latestLocation) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    let needsLocationUpdate = false\n    const nextBasepath = this.options.basepath ?? '/'\n    const nextRewriteOption = this.options.rewrite\n    const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath\n    const rewriteChanged = prevRewriteOption !== nextRewriteOption\n\n    if (basepathChanged || rewriteChanged) {\n      this.basepath = nextBasepath\n\n      const rewrites: Array<LocationRewrite> = []\n      if (trimPath(nextBasepath) !== '') {\n        rewrites.push(\n          rewriteBasepath({\n            basepath: nextBasepath,\n          }),\n        )\n      }\n      if (nextRewriteOption) {\n        rewrites.push(nextRewriteOption)\n      }\n\n      this.rewrite =\n        rewrites.length === 0\n          ? undefined\n          : rewrites.length === 1\n            ? rewrites[0]\n            : composeRewrites(rewrites)\n\n      if (this.history) {\n        this.updateLatestLocation()\n      }\n\n      needsLocationUpdate = true\n    }\n\n    if (needsLocationUpdate && this.__store) {\n      this.__store.state = {\n        ...this.state,\n        location: this.latestLocation,\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state(): RouterState<TRouteTree> {\n    return this.__store.state\n  }\n\n  updateLatestLocation = () => {\n    this.latestLocation = this.parseLocation(\n      this.history.location,\n      this.latestLocation,\n    )\n  }\n\n  buildRouteTree = () => {\n    const { routesById, routesByPath, flatRoutes } = processRouteTree({\n      routeTree: this.routeTree,\n      initRoute: (route, i) => {\n        route.init({\n          originalIndex: i,\n        })\n      },\n    })\n\n    this.routesById = routesById as RoutesById<TRouteTree>\n    this.routesByPath = routesByPath as RoutesByPath<TRouteTree>\n    this.flatRoutes = flatRoutes as Array<AnyRoute>\n\n    const notFoundRoute = this.options.notFoundRoute\n\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n      })\n      this.routesById[notFoundRoute.id] = notFoundRoute\n    }\n  }\n\n  /**\n   * Subscribe to router lifecycle events like `onBeforeNavigate`, `onLoad`,\n   * `onResolved`, etc. Returns an unsubscribe function.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType\n   */\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  /**\n   * Parse a HistoryLocation into a strongly-typed ParsedLocation using the\n   * current router options, rewrite rules and search parser/stringifier.\n   */\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    locationToParse,\n    previousLocation,\n  ) => {\n    const parse = ({\n      href,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      // Before we do any processing, we need to allow rewrites to modify the URL\n      // build up the full URL by combining the href from history with the router's origin\n      const fullUrl = new URL(href, this.origin)\n      const url = executeRewriteInput(this.rewrite, fullUrl)\n\n      const parsedSearch = this.options.parseSearch(url.search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n      // Make sure our final url uses the re-stringified pathname, search, and has for consistency\n      // (We were already doing this, so just keeping it for now)\n      url.search = searchStr\n\n      const fullPath = url.href.replace(url.origin, '')\n\n      const { pathname, hash } = url\n\n      return {\n        href: fullPath,\n        publicHref: href,\n        url: url.href,\n        pathname: decodePath(pathname),\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key // TODO: Remove in v2 - use __TSR_key instead\n      parsedTempLocation.state.__TSR_key = location.state.__TSR_key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n    return location\n  }\n\n  /** Resolve a path against the router basepath and trailing-slash policy. */\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      parseCache: this.parsePathnameCache,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    }\n\n    return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next.pathname,\n      opts?.dest?.to as string,\n    )\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? undefined)\n        : (parentMatch.context ?? this.options.context ?? undefined)\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? undefined\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            undefined\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath + loaderDepsHash\n\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const strictParams = existingMatch?._strictParams ?? usedParams\n\n      let paramsError: PathParamError | undefined = undefined\n\n      if (!existingMatch) {\n        const strictParseParams =\n          route.options.params?.parse ?? route.options.parseParams\n\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams as Record<string, string>),\n            )\n          } catch (err: any) {\n            paramsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw paramsError\n            }\n          }\n        }\n      }\n\n      Object.assign(routeParams, strictParams)\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError,\n          __routeContext: undefined,\n          _nonReactive: {\n            loadPromise: createControlledPromise(),\n          },\n          __beforeLoadContext: undefined,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not calling from router.buildLocation\n\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n\n        if (route.options.context) {\n          const contextFnContext: RouteContextOptions<any, any, any, any> = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts: any) =>\n              this.navigate({ ...opts, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches,\n          }\n          // Get the route context\n          match.__routeContext =\n            route.options.context(contextFnContext) ?? undefined\n        }\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n    })\n\n    return matches\n  }\n\n  /** a cache for `parsePathname` */\n  private parsePathnameCache: ParsePathnameCache = createLRUCache(1000)\n\n  getMatchedRoutes: GetMatchRoutesFn = (\n    pathname: string,\n    routePathname: string | undefined,\n  ) => {\n    return getMatchedRoutes({\n      pathname,\n      routePathname,\n      caseSensitive: this.options.caseSensitive,\n      routesByPath: this.routesByPath,\n      routesById: this.routesById,\n      flatRoutes: this.flatRoutes,\n      parseCache: this.parsePathnameCache,\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match._nonReactive.pendingTimeout)\n    match._nonReactive.pendingTimeout = undefined\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  /**\n   * Build the next ParsedLocation from navigation options without committing.\n   * Resolves `to`/`from`, params/search/hash/state, applies search validation\n   * and middlewares, and returns a stable, stringified location object.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType#buildlocation-method\n   */\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n    ): ParsedLocation => {\n      // We allow the caller to override the current location\n      const currentLocation = dest._fromLocation || this.latestLocation\n\n      const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n        _buildLocation: true,\n      })\n\n      // Now let's find the starting pathname\n      // This should default to the current location if no from is provided\n      const lastMatch = last(allCurrentLocationMatches)!\n\n      // check that from path exists in the current route tree\n      // do this check only on navigations during test or development\n      if (\n        dest.from &&\n        process.env.NODE_ENV !== 'production' &&\n        dest._isNavigate\n      ) {\n        const allFromMatches = this.getMatchedRoutes(\n          dest.from,\n          undefined,\n        ).matchedRoutes\n\n        const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n          return comparePaths(d.fullPath, dest.from!)\n        })\n\n        const matchedCurrent = findLast(allFromMatches, (d) => {\n          return comparePaths(d.fullPath, lastMatch.fullPath)\n        })\n\n        // for from to be invalid it shouldn't just be unmatched to currentLocation\n        // but the currentLocation should also be unmatched to from\n        if (!matchedFrom && !matchedCurrent) {\n          console.warn(`Could not find match for from: ${dest.from}`)\n        }\n      }\n\n      const defaultedFromPath =\n        dest.unsafeRelative === 'path'\n          ? currentLocation.pathname\n          : (dest.from ?? lastMatch.fullPath)\n\n      // ensure this includes the basePath if set\n      const fromPath = this.resolvePathWithBase(defaultedFromPath, '.')\n\n      // From search should always use the current location\n      const fromSearch = lastMatch.search\n      // Same with params. It can't hurt to provide as many as possible\n      const fromParams = { ...lastMatch.params }\n\n      // Resolve the next to\n      // ensure this includes the basePath if set\n      const nextTo = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, '.')\n\n      // Resolve the next params\n      const nextParams =\n        dest.params === false || dest.params === null\n          ? {}\n          : (dest.params ?? true) === true\n            ? fromParams\n            : Object.assign(\n                fromParams,\n                functionalUpdate(dest.params as any, fromParams),\n              )\n\n      // Interpolate the path first to get the actual resolved path, then match against that\n      const interpolatedNextTo = interpolatePath({\n        path: nextTo,\n        params: nextParams,\n        parseCache: this.parsePathnameCache,\n      }).interpolatedPath\n\n      const destRoutes = this.matchRoutes(interpolatedNextTo, undefined, {\n        _buildLocation: true,\n      }).map((d) => this.looseRoutesById[d.routeId]!)\n\n      // If there are any params, we need to stringify them\n      if (Object.keys(nextParams).length > 0) {\n        for (const route of destRoutes) {\n          const fn =\n            route.options.params?.stringify ?? route.options.stringifyParams\n          if (fn) {\n            Object.assign(nextParams, fn(nextParams))\n          }\n        }\n      }\n\n      const nextPathname = decodePath(\n        interpolatePath({\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          path: nextTo,\n          params: nextParams,\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath,\n      )\n\n      // Resolve the next search\n      let nextSearch = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        const validatedSearch = {}\n        destRoutes.forEach((route) => {\n          if (route.options.validateSearch) {\n            try {\n              Object.assign(\n                validatedSearch,\n                validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...nextSearch,\n                }),\n              )\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n            }\n          }\n        })\n        nextSearch = validatedSearch\n      }\n\n      nextSearch = applySearchMiddleware({\n        search: nextSearch,\n        dest,\n        destRoutes,\n        _includeValidateSearch: opts._includeValidateSearch,\n      })\n\n      // Replace the equal deep\n      nextSearch = replaceEqualDeep(fromSearch, nextSearch)\n\n      // Stringify the next search\n      const searchStr = this.options.stringifySearch(nextSearch)\n\n      // Resolve the next hash\n      const hash =\n        dest.hash === true\n          ? currentLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, currentLocation.hash)\n            : undefined\n\n      // Resolve the next hash string\n      const hashStr = hash ? `#${hash}` : ''\n\n      // Resolve the next state\n      let nextState =\n        dest.state === true\n          ? currentLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, currentLocation.state)\n            : {}\n\n      // Replace the equal deep\n      nextState = replaceEqualDeep(currentLocation.state, nextState)\n\n      // Create the full path of the location\n      const fullPath = `${nextPathname}${searchStr}${hashStr}`\n\n      // Create the new href with full origin\n      const url = new URL(fullPath, this.origin)\n\n      // If a rewrite function is provided, use it to rewrite the URL\n      const rewrittenUrl = executeRewriteOutput(this.rewrite, url)\n\n      return {\n        publicHref:\n          rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n        href: fullPath,\n        url: rewrittenUrl.href,\n        pathname: nextPathname,\n        search: nextSearch,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(\n            next.pathname,\n            {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            },\n            this.parsePathnameCache,\n          )\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from: _from, ...maskProps } = foundMask\n          maskedDest = {\n            from: opts.from,\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      if (maskedNext) {\n        next.maskedLocation = maskedNext\n      }\n\n      return next\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        from: opts.from,\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  /**\n   * Commit a previously built location to history (push/replace), optionally\n   * using view transitions and scroll restoration options.\n   */\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key', // TODO: Remove in v2 - use __TSR_key instead\n        '__TSR_key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl =\n      trimPathRight(this.latestLocation.href) === trimPathRight(next.href)\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                __TSR_key: undefined!,\n                key: undefined!, // TODO: Remove in v2 - use __TSR_key instead\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  /** Convenience helper: build a location from options, then commit it. */\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n  }\n\n  /**\n   * Imperatively navigate using standard `NavigateOptions`. When `reloadDocument`\n   * or an absolute `href` is provided, performs a full document navigation.\n   * Otherwise, builds and commits a client-side location.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType\n   */\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (!reloadDocument && href) {\n      try {\n        new URL(`${href}`)\n        reloadDocument = true\n      } catch {}\n    }\n\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = location.url\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return Promise.resolve()\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n      _isNavigate: true,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  beforeLoad = () => {\n    // Cancel any pending matches\n    this.cancelMatches()\n    this.updateLatestLocation()\n\n    if (this.isServer) {\n      // for SPAs on the initial load, this is handled by the Transitioner\n      const nextLocation = this.buildLocation({\n        to: this.latestLocation.pathname,\n        search: true,\n        params: true,\n        hash: true,\n        state: true,\n        _includeValidateSearch: true,\n      })\n\n      // Normalize URLs for comparison to handle encoding differences\n      // Browser history always stores encoded URLs while buildLocation may produce decoded URLs\n      const normalizeUrl = (url: string) => {\n        try {\n          return encodeURI(decodeURI(url))\n        } catch {\n          return url\n        }\n      }\n\n      if (\n        trimPath(normalizeUrl(this.latestLocation.href)) !==\n        trimPath(normalizeUrl(nextLocation.href))\n      ) {\n        let href = nextLocation.url\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, '') || '/'\n        }\n\n        throw redirect({ href })\n      }\n    }\n\n    // Match the routes\n    const pendingMatches = this.matchRoutes(this.latestLocation)\n\n    // Ingest the new matches\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'pending',\n      statusCode: 200,\n      isLoading: true,\n      location: this.latestLocation,\n      pendingMatches,\n      // If a cached moved to pendingMatches, remove it from cachedMatches\n      cachedMatches: s.cachedMatches.filter(\n        (d) => !pendingMatches.some((e) => e.id === d.id),\n      ),\n    }))\n  }\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    let redirect: AnyRedirect | undefined\n    let notFound: NotFoundError | undefined\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          this.beforeLoad()\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await loadMatches({\n            router: this,\n            sync: opts?.sync,\n            matches: this.state.pendingMatches as Array<AnyRouteMatch>,\n            location: next,\n            updateMatch: this.updateMatch,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              // Wrap batch in framework-specific transition wrapper (e.g., Solid's startTransition)\n              this.startTransition(() => {\n                this.startViewTransition(async () => {\n                  // this.viewTransitionPromise = createControlledPromise<true>()\n\n                  // Commit the pending matches. If a previous match was\n                  // removed, place it in the cachedMatches\n                  let exitingMatches: Array<AnyRouteMatch> = []\n                  let enteringMatches: Array<AnyRouteMatch> = []\n                  let stayingMatches: Array<AnyRouteMatch> = []\n\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches\n                      const newMatches = s.pendingMatches || s.matches\n\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id),\n                      )\n                      enteringMatches = newMatches.filter(\n                        (match) =>\n                          !previousMatches.some((d) => d.id === match.id),\n                      )\n                      stayingMatches = newMatches.filter((match) =>\n                        previousMatches.some((d) => d.id === match.id),\n                      )\n\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: undefined,\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter((d) => d.status !== 'error'),\n                        ],\n                      }\n                    })\n                    this.clearExpiredCache()\n                  })\n\n                  //\n                  ;(\n                    [\n                      [exitingMatches, 'onLeave'],\n                      [enteringMatches, 'onEnter'],\n                      [stayingMatches, 'onStay'],\n                    ] as const\n                  ).forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId]!.options[hook]?.(\n                        match,\n                      )\n                    })\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect.options,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.status\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    let newStatusCode: number | undefined = undefined\n    if (this.hasNotFoundMatch()) {\n      newStatusCode = 404\n    } else if (this.__store.state.matches.some((d) => d.status === 'error')) {\n      newStatusCode = 500\n    }\n    if (newStatusCode !== undefined) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: newStatusCode,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        if (resolvedViewTransitionTypes === false) {\n          fn()\n          return\n        }\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    const matchesKey = this.state.pendingMatches?.some((d) => d.id === id)\n      ? 'pendingMatches'\n      : this.state.matches.some((d) => d.id === id)\n        ? 'matches'\n        : this.state.cachedMatches.some((d) => d.id === id)\n          ? 'cachedMatches'\n          : ''\n\n    if (matchesKey) {\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) => (d.id === id ? updater(d) : d)),\n      }))\n    }\n  }\n\n  getMatch: GetMatchFn = (matchId: string) => {\n    const findFn = (d: { id: string }) => d.id === matchId\n    return (\n      this.state.cachedMatches.find(findFn) ??\n      this.state.pendingMatches?.find(findFn) ??\n      this.state.matches.find(findFn)\n    )\n  }\n\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(opts?.forcePending || d.status === 'error'\n            ? ({ status: 'pending', error: undefined } as const)\n            : undefined),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.shouldViewTransition = false\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (redirect: AnyRedirect): AnyRedirect => {\n    if (!redirect.options.href) {\n      const location = this.buildLocation(redirect.options)\n      let href = location.url\n      if (this.origin && href.startsWith(this.origin)) {\n        href = href.replace(this.origin, '') || '/'\n      }\n      redirect.options.href = location.href\n      redirect.headers.set('Location', href)\n    }\n    if (!redirect.headers.get('Location')) {\n      redirect.headers.set('Location', redirect.options.href)\n    }\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      const isError = d.status === 'error'\n      if (isError) return true\n\n      const gcEligible = Date.now() - d.updatedAt >= gcTime\n      return gcEligible\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = loadRouteChunk\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await loadMatches({\n        router: this,\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.options.reloadDocument) {\n          return undefined\n        }\n\n        return await this.preloadRoute({\n          ...err.options,\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = matchPathname(\n      baseLocation.pathname,\n      {\n        ...opts,\n        to: next.pathname,\n      },\n      this.parsePathnameCache,\n    ) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match\n        : false\n    }\n\n    return match\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n  }\n\n  serverSsr?: ServerSsr\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n/** Error thrown when search parameter validation fails. */\nexport class SearchParamError extends Error {}\n\n/** Error thrown when path parameter parsing/validation fails. */\nexport class PathParamError extends Error {}\n\nconst normalize = (str: string) =>\n  str.endsWith('/') && str.length > 1 ? str.slice(0, -1) : str\nfunction comparePaths(a: string, b: string) {\n  return normalize(a) === normalize(b)\n}\n\n/**\n * Lazily import a module function and forward arguments to it, retaining\n * parameter and return types for the selected export key.\n */\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\n/** Create an initial RouterState from a parsed location. */\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\n/**\n * Build the matched route chain and extract params for a pathname.\n * Falls back to the root route if no specific route is found.\n */\nexport function getMatchedRoutes<TRouteLike extends RouteLike>({\n  pathname,\n  routePathname,\n  caseSensitive,\n  routesByPath,\n  routesById,\n  flatRoutes,\n  parseCache,\n}: {\n  pathname: string\n  routePathname?: string\n  caseSensitive?: boolean\n  routesByPath: Record<string, TRouteLike>\n  routesById: Record<string, TRouteLike>\n  flatRoutes: Array<TRouteLike>\n  parseCache?: ParsePathnameCache\n}) {\n  let routeParams: Record<string, string> = {}\n  const trimmedPath = trimPathRight(pathname)\n  const getMatchedParams = (route: TRouteLike) => {\n    const result = matchPathname(\n      trimmedPath,\n      {\n        to: route.fullPath,\n        caseSensitive: route.options?.caseSensitive ?? caseSensitive,\n        // we need fuzzy matching for `notFoundMode: 'fuzzy'`\n        fuzzy: true,\n      },\n      parseCache,\n    )\n    return result\n  }\n\n  let foundRoute: TRouteLike | undefined =\n    routePathname !== undefined ? routesByPath[routePathname] : undefined\n  if (foundRoute) {\n    routeParams = getMatchedParams(foundRoute)!\n  } else {\n    // iterate over flatRoutes to find the best match\n    // if we find a fuzzy matching route, keep looking for a perfect fit\n    let fuzzyMatch:\n      | { foundRoute: TRouteLike; routeParams: Record<string, string> }\n      | undefined = undefined\n    for (const route of flatRoutes) {\n      const matchedParams = getMatchedParams(route)\n\n      if (matchedParams) {\n        if (\n          route.path !== '/' &&\n          (matchedParams as Record<string, string>)['**']\n        ) {\n          if (!fuzzyMatch) {\n            fuzzyMatch = { foundRoute: route, routeParams: matchedParams }\n          }\n        } else {\n          foundRoute = route\n          routeParams = matchedParams\n          break\n        }\n      }\n    }\n    // did not find a perfect fit, so take the fuzzy matching route if it exists\n    if (!foundRoute && fuzzyMatch) {\n      foundRoute = fuzzyMatch.foundRoute\n      routeParams = fuzzyMatch.routeParams\n    }\n  }\n\n  let routeCursor: TRouteLike = foundRoute || routesById[rootRouteId]!\n\n  const matchedRoutes: Array<TRouteLike> = [routeCursor]\n\n  while (routeCursor.parentRoute) {\n    routeCursor = routeCursor.parentRoute as TRouteLike\n    matchedRoutes.push(routeCursor)\n  }\n  matchedRoutes.reverse()\n\n  return { matchedRoutes, routeParams, foundRoute }\n}\n\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch,\n}: {\n  search: any\n  dest: BuildNextOptions\n  destRoutes: Array<AnyRoute>\n  _includeValidateSearch: boolean | undefined\n}) {\n  const allMiddlewares =\n    destRoutes.reduce(\n      (acc, route) => {\n        const middlewares: Array<SearchMiddleware<any>> = []\n\n        if ('search' in route.options) {\n          if (route.options.search?.middlewares) {\n            middlewares.push(...route.options.search.middlewares)\n          }\n        }\n        // TODO remove preSearchFilters and postSearchFilters in v2\n        else if (\n          route.options.preSearchFilters ||\n          route.options.postSearchFilters\n        ) {\n          const legacyMiddleware: SearchMiddleware<any> = ({\n            search,\n            next,\n          }) => {\n            let nextSearch = search\n\n            if (\n              'preSearchFilters' in route.options &&\n              route.options.preSearchFilters\n            ) {\n              nextSearch = route.options.preSearchFilters.reduce(\n                (prev, next) => next(prev),\n                search,\n              )\n            }\n\n            const result = next(nextSearch)\n\n            if (\n              'postSearchFilters' in route.options &&\n              route.options.postSearchFilters\n            ) {\n              return route.options.postSearchFilters.reduce(\n                (prev, next) => next(prev),\n                result,\n              )\n            }\n\n            return result\n          }\n          middlewares.push(legacyMiddleware)\n        }\n\n        if (_includeValidateSearch && route.options.validateSearch) {\n          const validate: SearchMiddleware<any> = ({ search, next }) => {\n            const result = next(search)\n            try {\n              const validatedSearch = {\n                ...result,\n                ...(validateSearch(route.options.validateSearch, result) ??\n                  undefined),\n              }\n              return validatedSearch\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n              return result\n            }\n          }\n\n          middlewares.push(validate)\n        }\n\n        return acc.concat(middlewares)\n      },\n      [] as Array<SearchMiddleware<any>>,\n    ) ?? []\n\n  // the chain ends here since `next` is not called\n  const final: SearchMiddleware<any> = ({ search }) => {\n    if (!dest.search) {\n      return {}\n    }\n    if (dest.search === true) {\n      return search\n    }\n    return functionalUpdate(dest.search, search)\n  }\n\n  allMiddlewares.push(final)\n\n  const applyNext = (index: number, currentSearch: any): any => {\n    // no more middlewares left, return the current search\n    if (index >= allMiddlewares.length) {\n      return currentSearch\n    }\n\n    const middleware = allMiddlewares[index]!\n\n    const next = (newSearch: any): any => {\n      return applyNext(index + 1, newSearch)\n    }\n\n    return middleware({ search: currentSearch, next })\n  }\n\n  // Start applying middlewares\n  return applyNext(0, search)\n}\n"],"names":["createBrowserHistory","Store","setupScrollRestoration","trimPath","rewriteBasepath","composeRewrites","processRouteTree","executeRewriteInput","decodePath","replaceEqualDeep","path","resolvePath","cleanPath","createLRUCache","last","findLast","functionalUpdate","interpolatePath","executeRewriteOutput","matchPathname","deepEqual","trimPathRight","createControlledPromise","parseHref","redirect","notFound","loadMatches","batch","isRedirect","isNotFound","loadRouteChunk","defaultStringifySearch","defaultParseSearch","rootRouteId","routeNeedsPreload","opts","validateSearch","search","next"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"router.cjs","sources":["../../src/router.ts"],"sourcesContent":["import { Store, batch } from '@tanstack/store'\nimport { createBrowserHistory, parseHref } from '@tanstack/history'\nimport {\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  last,\n  replaceEqualDeep,\n} from './utils'\nimport { processRouteTree } from './process-route-tree'\nimport {\n  cleanPath,\n  interpolatePath,\n  matchPathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, redirect } from './redirect'\nimport { createLRUCache } from './lru-cache'\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from './load-matches'\nimport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath,\n} from './rewrite'\nimport type { ParsePathnameCache } from './path'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  Awaitable,\n  Constrain,\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteLike,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest } from './manifest'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\nimport type {\n  AnySerializationAdapter,\n  ValidateSerializableInput,\n} from './ssr/serializer/transformer'\n// import type { AnyRouterConfig } from './config'\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // Lots of things on here like...\n  // router\n  // config\n  // ssr\n}\n\nexport type RegisteredSsr<TRegister = Register> = TRegister extends {\n  ssr: infer TSSR\n}\n  ? TSSR\n  : false\n\nexport type RegisteredRouter<TRegister = Register> = TRegister extends {\n  router: infer TRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type RegisteredConfigType<TRegister, TKey> = TRegister extends {\n  config: infer TConfig\n}\n  ? TConfig extends {\n      '~types': infer TTypes\n    }\n    ? TKey extends keyof TTypes\n      ? TTypes[TKey]\n      : unknown\n    : unknown\n  : unknown\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport type SSROption = boolean | 'data-only'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated = undefined,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `preloadIntentProximity` a route should use if no preloadIntentProximity is provided.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadintentproximity-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-intent-proximity)\n   */\n  defaultPreloadIntentProximity?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * ```\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n\n  additionalContext?: any\n\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => Constrain<\n    TDehydrated,\n    ValidateSerializableInput<Register, TDehydrated>\n  >\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => Awaitable<void>\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  /**\n   * @default false\n   */\n  isShell?: boolean\n\n  /**\n   * @default false\n   */\n  isPrerendering?: boolean\n\n  /**\n   * The default `ssr` a route should use if no `ssr` is provided.\n   *\n   * @default true\n   */\n  defaultSsr?: SSROption\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?:\n    | boolean\n    | ((opts: { location: ParsedLocation }) => boolean)\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n\n  /**\n   * When `true`, disables the global catch boundary that normally wraps all route matches.\n   * This allows unhandled errors to bubble up to top-level error handlers in the browser.\n   *\n   * Useful for testing tools (like Storybook Test Runner), error reporting services,\n   * and debugging scenarios where you want errors to reach the browser's global error handlers.\n   *\n   * @default false\n   */\n  disableGlobalCatchBoundary?: boolean\n\n  serializationAdapters?: ReadonlyArray<AnySerializationAdapter>\n  /**\n   * Configures how the router will rewrite the location between the actual href and the internal href of the router.\n   *\n   * @default undefined\n   * @description You can provide a custom rewrite pair (in/out).\n   * This is useful for shifting data from the origin to the path (for things like subdomain routing), or other advanced use cases.\n   */\n  rewrite?: LocationRewrite\n  origin?: string\n  ssr?: {\n    nonce?: string\n  }\n}\n\nexport type LocationRewrite = {\n  /**\n   * A function that will be called to rewrite the URL before it is interpreted by the router from the history instance.\n   *\n   * @default undefined\n   */\n  input?: LocationRewriteFunction\n  /**\n   * A function that will be called to rewrite the URL before it is committed to the actual history instance from the router.\n   *\n   * @default undefined\n   */\n  output?: LocationRewriteFunction\n}\n\n/**\n * A function that will be called to rewrite the URL.\n *\n * @param url The URL to rewrite.\n * @returns The rewritten URL (as a URL instance or full href string) or undefined if no rewrite is needed.\n */\nexport type LocationRewriteFunction = ({\n  url,\n}: {\n  url: URL\n}) => undefined | string | URL\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: AnyRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  href?: string\n  _fromLocation?: ParsedLocation\n  unsafeRelative?: 'path'\n  _isNavigate?: boolean\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport interface RouterEvents {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context' | 'serializationAdapters' | 'defaultSsr'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n  forcePending?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  locationToParse: HistoryLocation,\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  pathname: string,\n  routePathname: string | undefined,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch?: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<MakeRouteMatchUnion>\n  /**\n   * @deprecated use the following signature instead\n   */\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => void\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSsr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  isDehydrated: () => boolean\n  onRenderFinished: (listener: () => void) => void\n  dehydrate: () => Promise<void>\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string> | false)\n}\n\n// TODO where is this used? can we remove this?\n/**\n * Convert an unknown error into a minimal, serializable object.\n * Includes name and message (and stack in development).\n */\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n\n/** Options for configuring trailing-slash behavior. */\nexport const trailingSlashOptions = {\n  always: 'always',\n  never: 'never',\n  preserve: 'preserve',\n} as const\n\nexport type TrailingSlashOption =\n  (typeof trailingSlashOptions)[keyof typeof trailingSlashOptions]\n\n/**\n * Compute whether path, href or hash changed between previous and current\n * resolved locations in router state.\n */\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\n/**\n * Core, framework-agnostic router engine that powers TanStack Router.\n *\n * Provides navigation, matching, loading, preloading, caching and event APIs\n * used by framework adapters (React/Solid). Prefer framework helpers like\n * `createRouter` in app code.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType\n */\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  rewrite?: LocationRewrite\n  origin?: string\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      self.__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  isShell() {\n    return !!this.options.isShell\n  }\n\n  isPrerendering() {\n    return !!this.options.isPrerendering\n  }\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const prevOptions = this.options\n    const prevBasepath = this.basepath ?? prevOptions?.basepath ?? '/'\n    const basepathWasUnset = this.basepath === undefined\n    const prevRewriteOption = prevOptions?.rewrite\n\n    this.options = {\n      ...prevOptions,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (!this.options.history) {\n        if (!this.isServer) {\n          this.history = createBrowserHistory() as TRouterHistory\n        }\n      } else {\n        this.history = this.options.history\n      }\n    }\n\n    this.origin = this.options.origin\n    if (!this.origin) {\n      if (!this.isServer && window?.origin && window.origin !== 'null') {\n        this.origin = window.origin\n      } else {\n        // fallback for the server, can be overridden by calling router.update({origin}) on the server\n        this.origin = 'http://localhost'\n      }\n    }\n\n    if (this.history) {\n      this.updateLatestLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store && this.latestLocation) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    let needsLocationUpdate = false\n    const nextBasepath = this.options.basepath ?? '/'\n    const nextRewriteOption = this.options.rewrite\n    const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath\n    const rewriteChanged = prevRewriteOption !== nextRewriteOption\n\n    if (basepathChanged || rewriteChanged) {\n      this.basepath = nextBasepath\n\n      const rewrites: Array<LocationRewrite> = []\n      if (trimPath(nextBasepath) !== '') {\n        rewrites.push(\n          rewriteBasepath({\n            basepath: nextBasepath,\n          }),\n        )\n      }\n      if (nextRewriteOption) {\n        rewrites.push(nextRewriteOption)\n      }\n\n      this.rewrite =\n        rewrites.length === 0\n          ? undefined\n          : rewrites.length === 1\n            ? rewrites[0]\n            : composeRewrites(rewrites)\n\n      if (this.history) {\n        this.updateLatestLocation()\n      }\n\n      needsLocationUpdate = true\n    }\n\n    if (needsLocationUpdate && this.__store) {\n      this.__store.state = {\n        ...this.state,\n        location: this.latestLocation,\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state(): RouterState<TRouteTree> {\n    return this.__store.state\n  }\n\n  updateLatestLocation = () => {\n    this.latestLocation = this.parseLocation(\n      this.history.location,\n      this.latestLocation,\n    )\n  }\n\n  buildRouteTree = () => {\n    const { routesById, routesByPath, flatRoutes } = processRouteTree({\n      routeTree: this.routeTree,\n      initRoute: (route, i) => {\n        route.init({\n          originalIndex: i,\n        })\n      },\n    })\n\n    this.routesById = routesById as RoutesById<TRouteTree>\n    this.routesByPath = routesByPath as RoutesByPath<TRouteTree>\n    this.flatRoutes = flatRoutes as Array<AnyRoute>\n\n    const notFoundRoute = this.options.notFoundRoute\n\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n      })\n      this.routesById[notFoundRoute.id] = notFoundRoute\n    }\n  }\n\n  /**\n   * Subscribe to router lifecycle events like `onBeforeNavigate`, `onLoad`,\n   * `onResolved`, etc. Returns an unsubscribe function.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType\n   */\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  /**\n   * Parse a HistoryLocation into a strongly-typed ParsedLocation using the\n   * current router options, rewrite rules and search parser/stringifier.\n   */\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    locationToParse,\n    previousLocation,\n  ) => {\n    const parse = ({\n      href,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      // Before we do any processing, we need to allow rewrites to modify the URL\n      // build up the full URL by combining the href from history with the router's origin\n      const fullUrl = new URL(href, this.origin)\n      const url = executeRewriteInput(this.rewrite, fullUrl)\n\n      const parsedSearch = this.options.parseSearch(url.search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n      // Make sure our final url uses the re-stringified pathname, search, and has for consistency\n      // (We were already doing this, so just keeping it for now)\n      url.search = searchStr\n\n      const fullPath = url.href.replace(url.origin, '')\n\n      const { pathname, hash } = url\n\n      return {\n        href: fullPath,\n        publicHref: href,\n        url: url.href,\n        pathname: decodePath(pathname),\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key // TODO: Remove in v2 - use __TSR_key instead\n      parsedTempLocation.state.__TSR_key = location.state.__TSR_key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n    return location\n  }\n\n  /** Resolve a path against the router basepath and trailing-slash policy. */\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      parseCache: this.parsePathnameCache,\n      basepath: this.basepath,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    }\n\n    return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next.pathname,\n      opts?.dest?.to as string,\n    )\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? undefined)\n        : (parentMatch.context ?? this.options.context ?? undefined)\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? undefined\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            undefined\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath + loaderDepsHash\n\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const strictParams = existingMatch?._strictParams ?? usedParams\n\n      let paramsError: PathParamError | undefined = undefined\n\n      if (!existingMatch) {\n        const strictParseParams =\n          route.options.params?.parse ?? route.options.parseParams\n\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams as Record<string, string>),\n            )\n          } catch (err: any) {\n            paramsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw paramsError\n            }\n          }\n        }\n      }\n\n      Object.assign(routeParams, strictParams)\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError,\n          __routeContext: undefined,\n          _nonReactive: {\n            loadPromise: createControlledPromise(),\n          },\n          __beforeLoadContext: undefined,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not calling from router.buildLocation\n\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n\n        if (route.options.context) {\n          const contextFnContext: RouteContextOptions<any, any, any, any> = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts: any) =>\n              this.navigate({ ...opts, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches,\n          }\n          // Get the route context\n          match.__routeContext =\n            route.options.context(contextFnContext) ?? undefined\n        }\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n    })\n\n    return matches\n  }\n\n  /** a cache for `parsePathname` */\n  private parsePathnameCache: ParsePathnameCache = createLRUCache(1000)\n\n  getMatchedRoutes: GetMatchRoutesFn = (\n    pathname: string,\n    routePathname: string | undefined,\n  ) => {\n    return getMatchedRoutes({\n      basepath: this.basepath,\n      pathname,\n      routePathname,\n      caseSensitive: this.options.caseSensitive,\n      routesByPath: this.routesByPath,\n      routesById: this.routesById,\n      flatRoutes: this.flatRoutes,\n      parseCache: this.parsePathnameCache,\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match._nonReactive.pendingTimeout)\n    match._nonReactive.pendingTimeout = undefined\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  /**\n   * Build the next ParsedLocation from navigation options without committing.\n   * Resolves `to`/`from`, params/search/hash/state, applies search validation\n   * and middlewares, and returns a stable, stringified location object.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType#buildlocation-method\n   */\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n    ): ParsedLocation => {\n      // We allow the caller to override the current location\n      const currentLocation = dest._fromLocation || this.latestLocation\n\n      const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n        _buildLocation: true,\n      })\n\n      // Now let's find the starting pathname\n      // This should default to the current location if no from is provided\n      const lastMatch = last(allCurrentLocationMatches)!\n\n      // check that from path exists in the current route tree\n      // do this check only on navigations during test or development\n      if (\n        dest.from &&\n        process.env.NODE_ENV !== 'production' &&\n        dest._isNavigate\n      ) {\n        const allFromMatches = this.getMatchedRoutes(\n          dest.from,\n          undefined,\n        ).matchedRoutes\n\n        const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n          return comparePaths(d.fullPath, dest.from!)\n        })\n\n        const matchedCurrent = findLast(allFromMatches, (d) => {\n          return comparePaths(d.fullPath, lastMatch.fullPath)\n        })\n\n        // for from to be invalid it shouldn't just be unmatched to currentLocation\n        // but the currentLocation should also be unmatched to from\n        if (!matchedFrom && !matchedCurrent) {\n          console.warn(`Could not find match for from: ${dest.from}`)\n        }\n      }\n\n      const defaultedFromPath =\n        dest.unsafeRelative === 'path'\n          ? currentLocation.pathname\n          : (dest.from ?? lastMatch.fullPath)\n\n      // ensure this includes the basePath if set\n      const fromPath = this.resolvePathWithBase(defaultedFromPath, '.')\n\n      // From search should always use the current location\n      const fromSearch = lastMatch.search\n      // Same with params. It can't hurt to provide as many as possible\n      const fromParams = { ...lastMatch.params }\n\n      // Resolve the next to\n      // ensure this includes the basePath if set\n      const nextTo = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, '.')\n\n      // Resolve the next params\n      const nextParams =\n        dest.params === false || dest.params === null\n          ? {}\n          : (dest.params ?? true) === true\n            ? fromParams\n            : Object.assign(\n                fromParams,\n                functionalUpdate(dest.params as any, fromParams),\n              )\n\n      // Interpolate the path first to get the actual resolved path, then match against that\n      const interpolatedNextTo = interpolatePath({\n        path: nextTo,\n        params: nextParams,\n        parseCache: this.parsePathnameCache,\n      }).interpolatedPath\n\n      const destRoutes = this.matchRoutes(interpolatedNextTo, undefined, {\n        _buildLocation: true,\n      }).map((d) => this.looseRoutesById[d.routeId]!)\n\n      // If there are any params, we need to stringify them\n      if (Object.keys(nextParams).length > 0) {\n        for (const route of destRoutes) {\n          const fn =\n            route.options.params?.stringify ?? route.options.stringifyParams\n          if (fn) {\n            Object.assign(nextParams, fn(nextParams))\n          }\n        }\n      }\n\n      const nextPathname = decodePath(\n        interpolatePath({\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          path: nextTo,\n          params: nextParams,\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath,\n      )\n\n      // Resolve the next search\n      let nextSearch = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        const validatedSearch = {}\n        destRoutes.forEach((route) => {\n          if (route.options.validateSearch) {\n            try {\n              Object.assign(\n                validatedSearch,\n                validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...nextSearch,\n                }),\n              )\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n            }\n          }\n        })\n        nextSearch = validatedSearch\n      }\n\n      nextSearch = applySearchMiddleware({\n        search: nextSearch,\n        dest,\n        destRoutes,\n        _includeValidateSearch: opts._includeValidateSearch,\n      })\n\n      // Replace the equal deep\n      nextSearch = replaceEqualDeep(fromSearch, nextSearch)\n\n      // Stringify the next search\n      const searchStr = this.options.stringifySearch(nextSearch)\n\n      // Resolve the next hash\n      const hash =\n        dest.hash === true\n          ? currentLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, currentLocation.hash)\n            : undefined\n\n      // Resolve the next hash string\n      const hashStr = hash ? `#${hash}` : ''\n\n      // Resolve the next state\n      let nextState =\n        dest.state === true\n          ? currentLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, currentLocation.state)\n            : {}\n\n      // Replace the equal deep\n      nextState = replaceEqualDeep(currentLocation.state, nextState)\n\n      // Create the full path of the location\n      const fullPath = `${nextPathname}${searchStr}${hashStr}`\n\n      // Create the new href with full origin\n      const url = new URL(fullPath, this.origin)\n\n      // If a rewrite function is provided, use it to rewrite the URL\n      const rewrittenUrl = executeRewriteOutput(this.rewrite, url)\n\n      return {\n        publicHref:\n          rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n        href: fullPath,\n        url: rewrittenUrl.href,\n        pathname: nextPathname,\n        search: nextSearch,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(\n            this.basepath,\n            next.pathname,\n            {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            },\n            this.parsePathnameCache,\n          )\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from: _from, ...maskProps } = foundMask\n          maskedDest = {\n            from: opts.from,\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      if (maskedNext) {\n        next.maskedLocation = maskedNext\n      }\n\n      return next\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        from: opts.from,\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  /**\n   * Commit a previously built location to history (push/replace), optionally\n   * using view transitions and scroll restoration options.\n   */\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key', // TODO: Remove in v2 - use __TSR_key instead\n        '__TSR_key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl =\n      trimPathRight(this.latestLocation.href) === trimPathRight(next.href)\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                __TSR_key: undefined!,\n                key: undefined!, // TODO: Remove in v2 - use __TSR_key instead\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  /** Convenience helper: build a location from options, then commit it. */\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n  }\n\n  /**\n   * Imperatively navigate using standard `NavigateOptions`. When `reloadDocument`\n   * or an absolute `href` is provided, performs a full document navigation.\n   * Otherwise, builds and commits a client-side location.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType\n   */\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (!reloadDocument && href) {\n      try {\n        new URL(`${href}`)\n        reloadDocument = true\n      } catch {}\n    }\n\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = location.url\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return Promise.resolve()\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n      _isNavigate: true,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  beforeLoad = () => {\n    // Cancel any pending matches\n    this.cancelMatches()\n    this.updateLatestLocation()\n\n    if (this.isServer) {\n      // for SPAs on the initial load, this is handled by the Transitioner\n      const nextLocation = this.buildLocation({\n        to: this.latestLocation.pathname,\n        search: true,\n        params: true,\n        hash: true,\n        state: true,\n        _includeValidateSearch: true,\n      })\n\n      // Normalize URLs for comparison to handle encoding differences\n      // Browser history always stores encoded URLs while buildLocation may produce decoded URLs\n      const normalizeUrl = (url: string) => {\n        try {\n          return encodeURI(decodeURI(url))\n        } catch {\n          return url\n        }\n      }\n\n      if (\n        trimPath(normalizeUrl(this.latestLocation.href)) !==\n        trimPath(normalizeUrl(nextLocation.href))\n      ) {\n        let href = nextLocation.url\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, '') || '/'\n        }\n\n        throw redirect({ href })\n      }\n    }\n\n    // Match the routes\n    const pendingMatches = this.matchRoutes(this.latestLocation)\n\n    // Ingest the new matches\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'pending',\n      statusCode: 200,\n      isLoading: true,\n      location: this.latestLocation,\n      pendingMatches,\n      // If a cached moved to pendingMatches, remove it from cachedMatches\n      cachedMatches: s.cachedMatches.filter(\n        (d) => !pendingMatches.some((e) => e.id === d.id),\n      ),\n    }))\n  }\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    let redirect: AnyRedirect | undefined\n    let notFound: NotFoundError | undefined\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          this.beforeLoad()\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await loadMatches({\n            router: this,\n            sync: opts?.sync,\n            matches: this.state.pendingMatches as Array<AnyRouteMatch>,\n            location: next,\n            updateMatch: this.updateMatch,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              // Wrap batch in framework-specific transition wrapper (e.g., Solid's startTransition)\n              this.startTransition(() => {\n                this.startViewTransition(async () => {\n                  // this.viewTransitionPromise = createControlledPromise<true>()\n\n                  // Commit the pending matches. If a previous match was\n                  // removed, place it in the cachedMatches\n                  let exitingMatches: Array<AnyRouteMatch> = []\n                  let enteringMatches: Array<AnyRouteMatch> = []\n                  let stayingMatches: Array<AnyRouteMatch> = []\n\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches\n                      const newMatches = s.pendingMatches || s.matches\n\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id),\n                      )\n                      enteringMatches = newMatches.filter(\n                        (match) =>\n                          !previousMatches.some((d) => d.id === match.id),\n                      )\n                      stayingMatches = newMatches.filter((match) =>\n                        previousMatches.some((d) => d.id === match.id),\n                      )\n\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: undefined,\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter((d) => d.status !== 'error'),\n                        ],\n                      }\n                    })\n                    this.clearExpiredCache()\n                  })\n\n                  //\n                  ;(\n                    [\n                      [exitingMatches, 'onLeave'],\n                      [enteringMatches, 'onEnter'],\n                      [stayingMatches, 'onStay'],\n                    ] as const\n                  ).forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId]!.options[hook]?.(\n                        match,\n                      )\n                    })\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect.options,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.status\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    let newStatusCode: number | undefined = undefined\n    if (this.hasNotFoundMatch()) {\n      newStatusCode = 404\n    } else if (this.__store.state.matches.some((d) => d.status === 'error')) {\n      newStatusCode = 500\n    }\n    if (newStatusCode !== undefined) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: newStatusCode,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        if (resolvedViewTransitionTypes === false) {\n          fn()\n          return\n        }\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    const matchesKey = this.state.pendingMatches?.some((d) => d.id === id)\n      ? 'pendingMatches'\n      : this.state.matches.some((d) => d.id === id)\n        ? 'matches'\n        : this.state.cachedMatches.some((d) => d.id === id)\n          ? 'cachedMatches'\n          : ''\n\n    if (matchesKey) {\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) => (d.id === id ? updater(d) : d)),\n      }))\n    }\n  }\n\n  getMatch: GetMatchFn = (matchId: string) => {\n    const findFn = (d: { id: string }) => d.id === matchId\n    return (\n      this.state.cachedMatches.find(findFn) ??\n      this.state.pendingMatches?.find(findFn) ??\n      this.state.matches.find(findFn)\n    )\n  }\n\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(opts?.forcePending || d.status === 'error'\n            ? ({ status: 'pending', error: undefined } as const)\n            : undefined),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.shouldViewTransition = false\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (redirect: AnyRedirect): AnyRedirect => {\n    if (!redirect.options.href) {\n      const location = this.buildLocation(redirect.options)\n      let href = location.url\n      if (this.origin && href.startsWith(this.origin)) {\n        href = href.replace(this.origin, '') || '/'\n      }\n      redirect.options.href = location.href\n      redirect.headers.set('Location', href)\n    }\n    if (!redirect.headers.get('Location')) {\n      redirect.headers.set('Location', redirect.options.href)\n    }\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      const isError = d.status === 'error'\n      if (isError) return true\n\n      const gcEligible = Date.now() - d.updatedAt >= gcTime\n      return gcEligible\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = loadRouteChunk\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await loadMatches({\n        router: this,\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.options.reloadDocument) {\n          return undefined\n        }\n\n        return await this.preloadRoute({\n          ...err.options,\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = matchPathname(\n      this.basepath,\n      baseLocation.pathname,\n      {\n        ...opts,\n        to: next.pathname,\n      },\n      this.parsePathnameCache,\n    ) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match\n        : false\n    }\n\n    return match\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n  }\n\n  serverSsr?: ServerSsr\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n/** Error thrown when search parameter validation fails. */\nexport class SearchParamError extends Error {}\n\n/** Error thrown when path parameter parsing/validation fails. */\nexport class PathParamError extends Error {}\n\nconst normalize = (str: string) =>\n  str.endsWith('/') && str.length > 1 ? str.slice(0, -1) : str\nfunction comparePaths(a: string, b: string) {\n  return normalize(a) === normalize(b)\n}\n\n/**\n * Lazily import a module function and forward arguments to it, retaining\n * parameter and return types for the selected export key.\n */\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\n/** Create an initial RouterState from a parsed location. */\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\n/**\n * Build the matched route chain and extract params for a pathname.\n * Falls back to the root route if no specific route is found.\n */\nexport function getMatchedRoutes<TRouteLike extends RouteLike>({\n  basepath = '/',\n  pathname,\n  routePathname,\n  caseSensitive,\n  routesByPath,\n  routesById,\n  flatRoutes,\n  parseCache,\n}: {\n  pathname: string\n  routePathname?: string\n  caseSensitive?: boolean\n  routesByPath: Record<string, TRouteLike>\n  routesById: Record<string, TRouteLike>\n  flatRoutes: Array<TRouteLike>\n  parseCache?: ParsePathnameCache\n  basepath?: string\n}) {\n  let routeParams: Record<string, string> = {}\n  const trimmedPath = trimPathRight(pathname)\n  const getMatchedParams = (route: TRouteLike) => {\n    const result = matchPathname(\n      basepath,\n      trimmedPath,\n      {\n        to: route.fullPath,\n        caseSensitive: route.options?.caseSensitive ?? caseSensitive,\n        // we need fuzzy matching for `notFoundMode: 'fuzzy'`\n        fuzzy: true,\n      },\n      parseCache,\n    )\n    return result\n  }\n\n  let foundRoute: TRouteLike | undefined =\n    routePathname !== undefined ? routesByPath[routePathname] : undefined\n  if (foundRoute) {\n    routeParams = getMatchedParams(foundRoute)!\n  } else {\n    // iterate over flatRoutes to find the best match\n    // if we find a fuzzy matching route, keep looking for a perfect fit\n    let fuzzyMatch:\n      | { foundRoute: TRouteLike; routeParams: Record<string, string> }\n      | undefined = undefined\n    for (const route of flatRoutes) {\n      const matchedParams = getMatchedParams(route)\n\n      if (matchedParams) {\n        if (\n          route.path !== '/' &&\n          (matchedParams as Record<string, string>)['**']\n        ) {\n          if (!fuzzyMatch) {\n            fuzzyMatch = { foundRoute: route, routeParams: matchedParams }\n          }\n        } else {\n          foundRoute = route\n          routeParams = matchedParams\n          break\n        }\n      }\n    }\n    // did not find a perfect fit, so take the fuzzy matching route if it exists\n    if (!foundRoute && fuzzyMatch) {\n      foundRoute = fuzzyMatch.foundRoute\n      routeParams = fuzzyMatch.routeParams\n    }\n  }\n\n  let routeCursor: TRouteLike = foundRoute || routesById[rootRouteId]!\n\n  const matchedRoutes: Array<TRouteLike> = [routeCursor]\n\n  while (routeCursor.parentRoute) {\n    routeCursor = routeCursor.parentRoute as TRouteLike\n    matchedRoutes.push(routeCursor)\n  }\n  matchedRoutes.reverse()\n\n  return { matchedRoutes, routeParams, foundRoute }\n}\n\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch,\n}: {\n  search: any\n  dest: BuildNextOptions\n  destRoutes: Array<AnyRoute>\n  _includeValidateSearch: boolean | undefined\n}) {\n  const allMiddlewares =\n    destRoutes.reduce(\n      (acc, route) => {\n        const middlewares: Array<SearchMiddleware<any>> = []\n\n        if ('search' in route.options) {\n          if (route.options.search?.middlewares) {\n            middlewares.push(...route.options.search.middlewares)\n          }\n        }\n        // TODO remove preSearchFilters and postSearchFilters in v2\n        else if (\n          route.options.preSearchFilters ||\n          route.options.postSearchFilters\n        ) {\n          const legacyMiddleware: SearchMiddleware<any> = ({\n            search,\n            next,\n          }) => {\n            let nextSearch = search\n\n            if (\n              'preSearchFilters' in route.options &&\n              route.options.preSearchFilters\n            ) {\n              nextSearch = route.options.preSearchFilters.reduce(\n                (prev, next) => next(prev),\n                search,\n              )\n            }\n\n            const result = next(nextSearch)\n\n            if (\n              'postSearchFilters' in route.options &&\n              route.options.postSearchFilters\n            ) {\n              return route.options.postSearchFilters.reduce(\n                (prev, next) => next(prev),\n                result,\n              )\n            }\n\n            return result\n          }\n          middlewares.push(legacyMiddleware)\n        }\n\n        if (_includeValidateSearch && route.options.validateSearch) {\n          const validate: SearchMiddleware<any> = ({ search, next }) => {\n            const result = next(search)\n            try {\n              const validatedSearch = {\n                ...result,\n                ...(validateSearch(route.options.validateSearch, result) ??\n                  undefined),\n              }\n              return validatedSearch\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n              return result\n            }\n          }\n\n          middlewares.push(validate)\n        }\n\n        return acc.concat(middlewares)\n      },\n      [] as Array<SearchMiddleware<any>>,\n    ) ?? []\n\n  // the chain ends here since `next` is not called\n  const final: SearchMiddleware<any> = ({ search }) => {\n    if (!dest.search) {\n      return {}\n    }\n    if (dest.search === true) {\n      return search\n    }\n    return functionalUpdate(dest.search, search)\n  }\n\n  allMiddlewares.push(final)\n\n  const applyNext = (index: number, currentSearch: any): any => {\n    // no more middlewares left, return the current search\n    if (index >= allMiddlewares.length) {\n      return currentSearch\n    }\n\n    const middleware = allMiddlewares[index]!\n\n    const next = (newSearch: any): any => {\n      return applyNext(index + 1, newSearch)\n    }\n\n    return middleware({ search: currentSearch, next })\n  }\n\n  // Start applying middlewares\n  return applyNext(0, search)\n}\n"],"names":["createBrowserHistory","Store","setupScrollRestoration","trimPath","rewriteBasepath","composeRewrites","processRouteTree","executeRewriteInput","decodePath","replaceEqualDeep","path","resolvePath","cleanPath","createLRUCache","last","findLast","functionalUpdate","interpolatePath","executeRewriteOutput","matchPathname","deepEqual","trimPathRight","createControlledPromise","parseHref","redirect","notFound","loadMatches","batch","isRedirect","isNotFound","loadRouteChunk","defaultStringifySearch","defaultParseSearch","rootRouteId","routeNeedsPreload","opts","validateSearch","search","next"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/cjs/router.d.cts b/dist/cjs/router.d.cts
index 53bb5c94437b4b59a2ae23aa65da011212f60e8e..6510c2e75c190992873faae69b873dbd45251df2 100644
--- a/dist/cjs/router.d.cts
+++ b/dist/cjs/router.d.cts
@@ -662,7 +662,7 @@ export declare function getInitialRouterState(location: ParsedLocation): RouterS
  * Build the matched route chain and extract params for a pathname.
  * Falls back to the root route if no specific route is found.
  */
-export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ pathname, routePathname, caseSensitive, routesByPath, routesById, flatRoutes, parseCache, }: {
+export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ basepath, pathname, routePathname, caseSensitive, routesByPath, routesById, flatRoutes, parseCache, }: {
     pathname: string;
     routePathname?: string;
     caseSensitive?: boolean;
@@ -670,6 +670,7 @@ export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ pathnam
     routesById: Record<string, TRouteLike>;
     flatRoutes: Array<TRouteLike>;
     parseCache?: ParsePathnameCache;
+    basepath?: string;
 }): {
     matchedRoutes: TRouteLike[];
     routeParams: Record<string, string>;
diff --git a/dist/esm/path.d.ts b/dist/esm/path.d.ts
index cc89736b5b1e09b2a907060aa73747576604367b..c1d5fc61c7ee0085028a02b155a797783bcce372 100644
--- a/dist/esm/path.d.ts
+++ b/dist/esm/path.d.ts
@@ -12,52 +12,23 @@ export interface Segment {
     readonly suffixSegment?: string;
     readonly hasStaticAfter?: boolean;
 }
-/** Join path segments, cleaning duplicate slashes between parts. */
-/** Join path segments, cleaning duplicate slashes between parts. */
 export declare function joinPaths(paths: Array<string | undefined>): string;
-/** Remove repeated slashes from a path string. */
-/** Remove repeated slashes from a path string. */
 export declare function cleanPath(path: string): string;
-/** Trim leading slashes (except preserving root '/'). */
-/** Trim leading slashes (except preserving root '/'). */
 export declare function trimPathLeft(path: string): string;
-/** Trim trailing slashes (except preserving root '/'). */
-/** Trim trailing slashes (except preserving root '/'). */
 export declare function trimPathRight(path: string): string;
-/** Trim both leading and trailing slashes. */
-/** Trim both leading and trailing slashes. */
 export declare function trimPath(path: string): string;
-/** Remove a trailing slash from value when appropriate for comparisons. */
 export declare function removeTrailingSlash(value: string, basepath: string): string;
-/**
- * Compare two pathnames for exact equality after normalizing trailing slashes
- * relative to the provided `basepath`.
- */
-/**
- * Compare two pathnames for exact equality after normalizing trailing slashes
- * relative to the provided `basepath`.
- */
 export declare function exactPathTest(pathName1: string, pathName2: string, basepath: string): boolean;
 interface ResolvePathOptions {
+    basepath: string;
     base: string;
     to: string;
     trailingSlash?: 'always' | 'never' | 'preserve';
+    caseSensitive?: boolean;
     parseCache?: ParsePathnameCache;
 }
-/**
- * Resolve a destination path against a base, honoring trailing-slash policy
- * and supporting relative segments (`.`/`..`) and absolute `to` values.
- */
-export declare function resolvePath({ base, to, trailingSlash, parseCache, }: ResolvePathOptions): string;
+export declare function resolvePath({ basepath, base, to, trailingSlash, caseSensitive, parseCache, }: ResolvePathOptions): string;
 export type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>;
-/**
- * Parse a pathname into an array of typed segments used by the router's
- * matcher. Results are optionally cached via an LRU cache.
- */
-/**
- * Parse a pathname into an array of typed segments used by the router's
- * matcher. Results are optionally cached via an LRU cache.
- */
 export declare const parsePathname: (pathname?: string, cache?: ParsePathnameCache) => ReadonlyArray<Segment>;
 interface InterpolatePathOptions {
     path?: string;
@@ -72,28 +43,8 @@ type InterPolatePathResult = {
     usedParams: Record<string, unknown>;
     isMissingParams: boolean;
 };
-/**
- * Interpolate params and wildcards into a route path template.
- *
- * - Encodes params safely (configurable allowed characters)
- * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards
- * - Optionally leaves placeholders or wildcards in place
- */
-/**
- * Interpolate params and wildcards into a route path template.
- * Encodes safely and supports optional params and custom decode char maps.
- */
 export declare function interpolatePath({ path, params, leaveWildcards, leaveParams, decodeCharMap, parseCache, }: InterpolatePathOptions): InterPolatePathResult;
-/**
- * Match a pathname against a route destination and return extracted params
- * or `undefined`. Uses the same parsing as the router for consistency.
- */
-/**
- * Match a pathname against a route destination and return extracted params
- * or `undefined`. Uses the same parsing as the router for consistency.
- */
-export declare function matchPathname(currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>, parseCache?: ParsePathnameCache): AnyPathParams | undefined;
-/** Low-level matcher that compares two path strings and extracts params. */
-/** Low-level matcher that compares two path strings and extracts params. */
-export declare function matchByPath(from: string, { to, fuzzy, caseSensitive, }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>, parseCache?: ParsePathnameCache): Record<string, string> | undefined;
+export declare function matchPathname(basepath: string, currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>, parseCache?: ParsePathnameCache): AnyPathParams | undefined;
+export declare function removeBasepath(basepath: string, pathname: string, caseSensitive?: boolean): string;
+export declare function matchByPath(basepath: string, from: string, { to, fuzzy, caseSensitive, }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>, parseCache?: ParsePathnameCache): Record<string, string> | undefined;
 export {};
diff --git a/dist/esm/path.js b/dist/esm/path.js
index f98078b3e38f2c59285c564c96c9565e2b3e1885..679ccc9e97245ca111302f7d317c38f879a0768d 100644
--- a/dist/esm/path.js
+++ b/dist/esm/path.js
@@ -70,11 +70,15 @@ function segmentToString(segment) {
   return value;
 }
 function resolvePath({
+  basepath,
   base,
   to,
   trailingSlash = "never",
+  caseSensitive,
   parseCache
 }) {
+  base = removeBasepath(basepath, base, caseSensitive);
+  to = removeBasepath(basepath, to, caseSensitive);
   let baseSegments = parsePathname(base, parseCache).slice();
   const toSegments = parsePathname(to, parseCache);
   if (baseSegments.length > 1 && last(baseSegments)?.value === "/") {
@@ -106,7 +110,7 @@ function resolvePath({
     }
   }
   const segmentValues = baseSegments.map(segmentToString);
-  const joined = joinPaths(segmentValues);
+  const joined = joinPaths([basepath, ...segmentValues]);
   return joined;
 }
 const parsePathname = (pathname, cache) => {
@@ -138,7 +142,8 @@ function baseParsePathname(pathname) {
   const split = pathname.split("/").filter(Boolean);
   segments.push(
     ...split.map((part) => {
-      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);
+      const partToMatch = part.slice(-1) === "_" ? part.slice(0, -1) : part;
+      const wildcardBracesMatch = partToMatch.match(WILDCARD_W_CURLY_BRACES_RE);
       if (wildcardBracesMatch) {
         const prefix = wildcardBracesMatch[1];
         const suffix = wildcardBracesMatch[2];
@@ -149,7 +154,7 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      const optionalParamBracesMatch = part.match(
+      const optionalParamBracesMatch = partToMatch.match(
         OPTIONAL_PARAM_W_CURLY_BRACES_RE
       );
       if (optionalParamBracesMatch) {
@@ -164,7 +169,7 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);
+      const paramBracesMatch = partToMatch.match(PARAM_W_CURLY_BRACES_RE);
       if (paramBracesMatch) {
         const prefix = paramBracesMatch[1];
         const paramName = paramBracesMatch[2];
@@ -176,8 +181,8 @@ function baseParsePathname(pathname) {
           suffixSegment: suffix || void 0
         };
       }
-      if (PARAM_RE.test(part)) {
-        const paramName = part.substring(1);
+      if (PARAM_RE.test(partToMatch)) {
+        const paramName = partToMatch.substring(1);
         return {
           type: SEGMENT_TYPE_PARAM,
           value: "$" + paramName,
@@ -185,7 +190,7 @@ function baseParsePathname(pathname) {
           suffixSegment: void 0
         };
       }
-      if (WILDCARD_RE.test(part)) {
+      if (WILDCARD_RE.test(partToMatch)) {
         return {
           type: SEGMENT_TYPE_WILDCARD,
           value: "$",
@@ -195,7 +200,7 @@ function baseParsePathname(pathname) {
       }
       return {
         type: SEGMENT_TYPE_PATHNAME,
-        value: part
+        value: partToMatch.includes("%25") ? partToMatch.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(partToMatch)
       };
     })
   );
@@ -238,7 +243,7 @@ function interpolatePath({
         usedParams["*"] = params._splat;
         const segmentPrefix = segment.prefixSegment || "";
         const segmentSuffix = segment.suffixSegment || "";
-        if (!params._splat) {
+        if (!("_splat" in params)) {
           isMissingParams = true;
           if (leaveWildcards) {
             return `${segmentPrefix}${segment.value}${segmentSuffix}`;
@@ -305,25 +310,63 @@ function encodePathParam(value, decodeCharMap) {
   }
   return encoded;
 }
-function matchPathname(currentPathname, matchLocation, parseCache) {
-  const pathParams = matchByPath(currentPathname, matchLocation, parseCache);
+function matchPathname(basepath, currentPathname, matchLocation, parseCache) {
+  const pathParams = matchByPath(
+    basepath,
+    currentPathname,
+    matchLocation,
+    parseCache
+  );
   if (matchLocation.to && !pathParams) {
     return;
   }
   return pathParams ?? {};
 }
-function matchByPath(from, {
+function removeBasepath(basepath, pathname, caseSensitive = false) {
+  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase();
+  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();
+  switch (true) {
+    // default behaviour is to serve app from the root - pathname
+    // left untouched
+    case normalizedBasepath === "/":
+      return pathname;
+    // shortcut for removing the basepath if it matches the pathname
+    case normalizedPathname === normalizedBasepath:
+      return "";
+    // in case pathname is shorter than basepath - there is
+    // nothing to remove
+    case pathname.length < basepath.length:
+      return pathname;
+    // avoid matching partial segments - strict equality handled
+    // earlier, otherwise, basepath separated from pathname with
+    // separator, therefore lack of separator means partial
+    // segment match (`/app` should not match `/application`)
+    case normalizedPathname[normalizedBasepath.length] !== "/":
+      return pathname;
+    // remove the basepath from the pathname if it starts with it
+    case normalizedPathname.startsWith(normalizedBasepath):
+      return pathname.slice(basepath.length);
+    // otherwise, return the pathname as is
+    default:
+      return pathname;
+  }
+}
+function matchByPath(basepath, from, {
   to,
   fuzzy,
   caseSensitive
 }, parseCache) {
-  const stringTo = to;
+  if (basepath !== "/" && !from.startsWith(basepath)) {
+    return void 0;
+  }
+  from = removeBasepath(basepath, from, caseSensitive);
+  to = removeBasepath(basepath, `${to ?? "$"}`, caseSensitive);
   const baseSegments = parsePathname(
     from.startsWith("/") ? from : `/${from}`,
     parseCache
   );
   const routeSegments = parsePathname(
-    stringTo.startsWith("/") ? stringTo : `/${stringTo}`,
+    to.startsWith("/") ? to : `/${to}`,
     parseCache
   );
   const params = {};
@@ -339,6 +382,10 @@ function matchByPath(from, {
 function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
   let baseIndex = 0;
   let routeIndex = 0;
+  let processedOptionals = 0;
+  const optionalCount = routeSegments.filter(
+    (seg) => seg.type === SEGMENT_TYPE_OPTIONAL_PARAM
+  ).length;
   while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {
     const baseSegment = baseSegments[baseIndex];
     const routeSegment = routeSegments[routeIndex];
@@ -444,10 +491,12 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
       }
       if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
         if (!baseSegment) {
+          processedOptionals++;
           routeIndex++;
           continue;
         }
         if (baseSegment.value === "/") {
+          processedOptionals++;
           routeIndex++;
           continue;
         }
@@ -473,18 +522,50 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
           }
         } else {
           let shouldMatchOptional = true;
+          const remainingOptionals = optionalCount - processedOptionals - 1 > 0;
+          const remainingRouteSegmentLength = (routeSegments.slice(-1)[0]?.value === "/" ? routeSegments.length - 1 : routeSegments.length) - routeIndex;
+          const remainingRequiredRouteSegmentCount = remainingRouteSegmentLength - (optionalCount - processedOptionals);
+          const remainingBaseSegmentCount = baseSegments.length - baseIndex;
           for (let lookAhead = routeIndex + 1; lookAhead < routeSegments.length; lookAhead++) {
             const futureRouteSegment = routeSegments[lookAhead];
-            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME && futureRouteSegment.value === baseSegment.value) {
-              shouldMatchOptional = false;
+            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {
+              if (caseSensitive ? futureRouteSegment.value === baseSegment.value : futureRouteSegment.value.toLowerCase() === baseSegment.value.toLowerCase()) {
+                shouldMatchOptional = false;
+              }
               break;
             }
-            if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {
-              if (baseSegments.length < routeSegments.length) {
+            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
+              if (remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount) {
                 shouldMatchOptional = false;
               }
               break;
             }
+            if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {
+              const followingRouteSegment = routeSegments[lookAhead + 1];
+              let isMatchedFurtherDown = false;
+              if (remainingOptionals && followingRouteSegment && (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME || followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM && (followingRouteSegment.prefixSegment || followingRouteSegment.suffixSegment))) {
+                const remainingRouteSegments = routeSegments.slice(
+                  lookAhead + 1
+                );
+                const remainingRouteSegmentLength2 = remainingRouteSegments.slice(-1)[0]?.value === "/" ? remainingRouteSegments.length - 1 : remainingRouteSegments.length;
+                const remainingBaseSegments = baseSegments.slice(baseIndex + 1);
+                isMatchedFurtherDown = remainingRouteSegmentLength2 === remainingBaseSegments.length && isMatch(
+                  remainingBaseSegments,
+                  remainingRouteSegments,
+                  { ...params },
+                  fuzzy,
+                  caseSensitive
+                );
+              }
+              if (!remainingOptionals || // remaining required segments equals remaining base segments
+              remainingRequiredRouteSegmentCount === remainingBaseSegmentCount || // matched by probe further down
+              isMatchedFurtherDown) {
+                if (remainingBaseSegmentCount < remainingRouteSegmentLength) {
+                  shouldMatchOptional = false;
+                }
+                break;
+              }
+            }
           }
           if (shouldMatchOptional) {
             _paramValue = decodeURIComponent(baseSegment.value);
@@ -495,6 +576,7 @@ function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
           params[routeSegment.value.substring(1)] = _paramValue;
           baseIndex++;
         }
+        processedOptionals++;
         routeIndex++;
         continue;
       }
@@ -529,6 +611,7 @@ export {
   matchByPath,
   matchPathname,
   parsePathname,
+  removeBasepath,
   removeTrailingSlash,
   resolvePath,
   trimPath,
diff --git a/dist/esm/path.js.map b/dist/esm/path.js.map
index 4cd60b8a5621faed14e595ba8978d55855eec02a..3134e2c43375f0df0bce3d98e56a8c30542b07be 100644
--- a/dist/esm/path.js.map
+++ b/dist/esm/path.js.map
@@ -1 +1 @@
-{"version":3,"file":"path.js","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { LRUCache } from './lru-cache'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport interface Segment {\n  readonly type:\n    | typeof SEGMENT_TYPE_PATHNAME\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  readonly value: string\n  readonly prefixSegment?: string\n  readonly suffixSegment?: string\n  // Indicates if there is a static segment after this required/optional param\n  readonly hasStaticAfter?: boolean\n}\n\n/** Join path segments, cleaning duplicate slashes between parts. */\n/** Join path segments, cleaning duplicate slashes between parts. */\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\n/** Remove repeated slashes from a path string. */\n/** Remove repeated slashes from a path string. */\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\n/** Trim leading slashes (except preserving root '/'). */\n/** Trim leading slashes (except preserving root '/'). */\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\n/** Trim trailing slashes (except preserving root '/'). */\n/** Trim trailing slashes (except preserving root '/'). */\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\n/** Trim both leading and trailing slashes. */\n/** Trim both leading and trailing slashes. */\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\n/** Remove a trailing slash from value when appropriate for comparisons. */\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\n/**\n * Compare two pathnames for exact equality after normalizing trailing slashes\n * relative to the provided `basepath`.\n */\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  parseCache?: ParsePathnameCache\n}\n\nfunction segmentToString(segment: Segment): string {\n  const { type, value } = segment\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value\n  }\n\n  const { prefixSegment, suffixSegment } = segment\n\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`\n    }\n  }\n\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`\n    }\n    return `{-$${param}}`\n  }\n\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`\n    }\n  }\n\n  // This case should never happen, should we throw instead?\n  return value\n}\n\n/**\n * Resolve a destination path against a base, honoring trailing-slash policy\n * and supporting relative segments (`.`/`..`) and absolute `to` values.\n */\nexport function resolvePath({\n  base,\n  to,\n  trailingSlash = 'never',\n  parseCache,\n}: ResolvePathOptions) {\n  let baseSegments = parsePathname(base, parseCache).slice()\n  const toSegments = parsePathname(to, parseCache)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index]!\n    const value = toSegment.value\n    if (value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (value === '..') {\n      baseSegments.pop()\n    } else if (value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)!.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map(segmentToString)\n  // const joined = joinPaths([basepath, ...segmentValues])\n  const joined = joinPaths(segmentValues)\n  return joined\n}\n\nexport type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>\n\n/**\n * Parse a pathname into an array of typed segments used by the router's\n * matcher. Results are optionally cached via an LRU cache.\n */\n/**\n * Parse a pathname into an array of typed segments used by the router's\n * matcher. Results are optionally cached via an LRU cache.\n */\nexport const parsePathname = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => {\n  if (!pathname) return []\n  const cached = cache?.get(pathname)\n  if (cached) return cached\n  const parsed = baseParsePathname(pathname)\n  cache?.set(pathname, parsed)\n  return parsed\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{-$paramName}suffix\n\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Optional param: `/foo/{-$bar}`\n * Optional param with Prefix and Suffix: `/foo/prefix{-$bar}suffix`\n\n * Future:\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nfunction baseParsePathname(pathname: string): ReadonlyArray<Segment> {\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for optional parameter format: prefix{-$paramName}suffix\n      const optionalParamBracesMatch = part.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE,\n      )\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1]\n        const paramName = optionalParamBracesMatch[2]!\n        const suffix = optionalParamBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName, // Now just $paramName (no prefix)\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(part)) {\n        const paramName = part.substring(1)\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(part)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n  parseCache?: ParsePathnameCache\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\n/**\n * Interpolate params and wildcards into a route path template.\n *\n * - Encodes params safely (configurable allowed characters)\n * - Supports `{-$optional}` segments, `{prefix{$id}suffix}` and `{$}` wildcards\n * - Optionally leaves placeholders or wildcards in place\n */\n/**\n * Interpolate params and wildcards into a route path template.\n * Encodes safely and supports optional params and custom decode char maps.\n */\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path, parseCache)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (key === '*' || key === '_splat') {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value\n      }\n\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat\n\n        // TODO: Deprecate *\n        usedParams['*'] = params._splat\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if _splat parameter is missing. _splat could be missing if undefined or an empty string or some other falsy value.\n        if (!params._splat) {\n          isMissingParams = true\n          // For missing splat parameters, just return the prefix and suffix without the wildcard\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`\n          }\n          // If there is a prefix or suffix, return them joined, otherwise omit the segment\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          return undefined\n        }\n\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1)\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if optional parameter is missing or undefined\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`\n          }\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          // If no prefix/suffix, omit the entire segment\n          return undefined\n        }\n\n        usedParams[key] = params[key]\n\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? ''}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\n/**\n * Match a pathname against a route destination and return extracted params\n * or `undefined`. Uses the same parsing as the router for consistency.\n */\n/**\n * Match a pathname against a route destination and return extracted params\n * or `undefined`. Uses the same parsing as the router for consistency.\n */\nexport function matchPathname(\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n  parseCache?: ParsePathnameCache,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(currentPathname, matchLocation, parseCache)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\n/** Low-level matcher that compares two path strings and extracts params. */\n/** Low-level matcher that compares two path strings and extracts params. */\nexport function matchByPath(\n  from: string,\n  {\n    to,\n    fuzzy,\n    caseSensitive,\n  }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n  parseCache?: ParsePathnameCache,\n): Record<string, string> | undefined {\n  const stringTo = to as string\n\n  // Parse the from and to\n  const baseSegments = parsePathname(\n    from.startsWith('/') ? from : `/${from}`,\n    parseCache,\n  )\n  const routeSegments = parsePathname(\n    stringTo.startsWith('/') ? stringTo : `/${stringTo}`,\n    parseCache,\n  )\n\n  const params: Record<string, string> = {}\n\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive,\n  )\n\n  return result ? params : undefined\n}\n\nfunction isMatch(\n  baseSegments: ReadonlyArray<Segment>,\n  routeSegments: ReadonlyArray<Segment>,\n  params: Record<string, string>,\n  fuzzy?: boolean,\n  caseSensitive?: boolean,\n): boolean {\n  let baseIndex = 0\n  let routeIndex = 0\n\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex]\n    const routeSegment = routeSegments[routeIndex]\n\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        // Capture all remaining segments for a wildcard\n        const remainingBaseSegments = baseSegments.slice(baseIndex)\n\n        let _splat: string\n\n        // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false\n\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if ('prefixSegment' in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false\n            }\n          }\n          if ('suffixSegment' in routeSegment) {\n            if (\n              !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n            ) {\n              return false\n            }\n          }\n\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n\n          // Remove the prefix and suffix from the rejoined splat\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length)\n          }\n\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length,\n            )\n          }\n\n          _splat = rejoinedSplat\n        } else {\n          // If no prefix/suffix, just rejoin the remaining segments\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n        }\n\n        // TODO: Deprecate *\n        params['*'] = _splat\n        params['_splat'] = _splat\n        return true\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === '/' && !baseSegment?.value) {\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          } else if (\n            routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()\n          ) {\n            return false\n          }\n          baseIndex++\n          routeIndex++\n          continue\n        } else {\n          return false\n        }\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false\n        }\n\n        if (baseSegment.value === '/') {\n          return false\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false\n          }\n\n          let paramValue = baseValue\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length)\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length)\n          }\n\n          _paramValue = decodeURIComponent(paramValue)\n          matched = true\n        } else {\n          // If no prefix/suffix, just decode the base segment value\n          _paramValue = decodeURIComponent(baseSegment.value)\n          matched = true\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        // Optional parameters can be missing - don't fail the match\n        if (!baseSegment) {\n          // No base segment for optional param - skip this route segment\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment.value === '/') {\n          // Skip slash segments for optional params\n          routeIndex++\n          continue\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this optional param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (\n            (!prefix || baseValue.startsWith(prefix)) &&\n            (!suffix || baseValue.endsWith(suffix))\n          ) {\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n            matched = true\n          }\n        } else {\n          // For optional params without prefix/suffix, we need to check if the current\n          // base segment should match this optional param or a later route segment\n\n          // Look ahead to see if there's a later route segment that matches the current base segment\n          let shouldMatchOptional = true\n          for (\n            let lookAhead = routeIndex + 1;\n            lookAhead < routeSegments.length;\n            lookAhead++\n          ) {\n            const futureRouteSegment = routeSegments[lookAhead]\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME &&\n              futureRouteSegment.value === baseSegment.value\n            ) {\n              // The current base segment matches a future pathname segment,\n              // so we should skip this optional parameter\n              shouldMatchOptional = false\n              break\n            }\n\n            // If we encounter a required param or wildcard, stop looking ahead\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n              futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n            ) {\n              if (baseSegments.length < routeSegments.length) {\n                shouldMatchOptional = false\n              }\n              break\n            }\n          }\n\n          if (shouldMatchOptional) {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n            matched = true\n          }\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n    }\n\n    // If we have base segments left but no route segments, it's a fuzzy match\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params['**'] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value),\n      )\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== '/'\n    }\n\n    // If we have route segments left but no base segments, check if remaining are optional\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      // Check if all remaining route segments are optional\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false\n        }\n      }\n      // All remaining are optional, so we can finish\n      break\n    }\n\n    break\n  }\n\n  return true\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"path.js","sources":["../../src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { LRUCache } from './lru-cache'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport const SEGMENT_TYPE_PATHNAME = 0\nexport const SEGMENT_TYPE_PARAM = 1\nexport const SEGMENT_TYPE_WILDCARD = 2\nexport const SEGMENT_TYPE_OPTIONAL_PARAM = 3\n\nexport interface Segment {\n  readonly type:\n    | typeof SEGMENT_TYPE_PATHNAME\n    | typeof SEGMENT_TYPE_PARAM\n    | typeof SEGMENT_TYPE_WILDCARD\n    | typeof SEGMENT_TYPE_OPTIONAL_PARAM\n  readonly value: string\n  readonly prefixSegment?: string\n  readonly suffixSegment?: string\n  // Indicates if there is a static segment after this required/optional param\n  readonly hasStaticAfter?: boolean\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  caseSensitive?: boolean\n  parseCache?: ParsePathnameCache\n}\n\nfunction segmentToString(segment: Segment): string {\n  const { type, value } = segment\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value\n  }\n\n  const { prefixSegment, suffixSegment } = segment\n\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`\n    }\n  }\n\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1)\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`\n    }\n    return `{-$${param}}`\n  }\n\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`\n    }\n  }\n\n  // This case should never happen, should we throw instead?\n  return value\n}\n\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n  caseSensitive,\n  parseCache,\n}: ResolvePathOptions) {\n  base = removeBasepath(basepath, base, caseSensitive)\n  to = removeBasepath(basepath, to, caseSensitive)\n\n  let baseSegments = parsePathname(base, parseCache).slice()\n  const toSegments = parsePathname(to, parseCache)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index]!\n    const value = toSegment.value\n    if (value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (value === '..') {\n      baseSegments.pop()\n    } else if (value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  }\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)!.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: '/' })\n    }\n  }\n\n  const segmentValues = baseSegments.map(segmentToString)\n  const joined = joinPaths([basepath, ...segmentValues])\n  return joined\n}\n\nexport type ParsePathnameCache = LRUCache<string, ReadonlyArray<Segment>>\nexport const parsePathname = (\n  pathname?: string,\n  cache?: ParsePathnameCache,\n): ReadonlyArray<Segment> => {\n  if (!pathname) return []\n  const cached = cache?.get(pathname)\n  if (cached) return cached\n  const parsed = baseParsePathname(pathname)\n  cache?.set(pathname, parsed)\n  return parsed\n}\n\nconst PARAM_RE = /^\\$.{1,}$/ // $paramName\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{$paramName}suffix\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE =\n  /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/ // prefix{-$paramName}suffix\n\nconst WILDCARD_RE = /^\\$$/ // $\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/ // prefix{$}suffix\n\n/**\n * Required: `/foo/$bar` ✅\n * Prefix and Suffix: `/foo/prefix${bar}suffix` ✅\n * Wildcard: `/foo/$` ✅\n * Wildcard with Prefix and Suffix: `/foo/prefix{$}suffix` ✅\n *\n * Optional param: `/foo/{-$bar}`\n * Optional param with Prefix and Suffix: `/foo/prefix{-$bar}suffix`\n\n * Future:\n * Optional named segment: `/foo/{bar}`\n * Optional named segment with Prefix and Suffix: `/foo/prefix{-bar}suffix`\n * Escape special characters:\n * - `/foo/[$]` - Static route\n * - `/foo/[$]{$foo} - Dynamic route with a static prefix of `$`\n * - `/foo/{$foo}[$]` - Dynamic route with a static suffix of `$`\n */\nfunction baseParsePathname(pathname: string): ReadonlyArray<Segment> {\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      // strip tailing underscore for non-nested paths\n      const partToMatch = part.slice(-1) === '_' ? part.slice(0, -1) : part\n\n      // Check for wildcard with curly braces: prefix{$}suffix\n      const wildcardBracesMatch = partToMatch.match(WILDCARD_W_CURLY_BRACES_RE)\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1]\n        const suffix = wildcardBracesMatch[2]\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for optional parameter format: prefix{-$paramName}suffix\n      const optionalParamBracesMatch = partToMatch.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE,\n      )\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1]\n        const paramName = optionalParamBracesMatch[2]!\n        const suffix = optionalParamBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName, // Now just $paramName (no prefix)\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for the new parameter format: prefix{$paramName}suffix\n      const paramBracesMatch = partToMatch.match(PARAM_W_CURLY_BRACES_RE)\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1]\n        const paramName = paramBracesMatch[2]\n        const suffix = paramBracesMatch[3]\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '' + paramName,\n          prefixSegment: prefix || undefined,\n          suffixSegment: suffix || undefined,\n        }\n      }\n\n      // Check for bare parameter format: $paramName (without curly braces)\n      if (PARAM_RE.test(partToMatch)) {\n        const paramName = partToMatch.substring(1)\n\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: '$' + paramName,\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Check for bare wildcard: $ (without curly braces)\n      if (WILDCARD_RE.test(partToMatch)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: '$',\n          prefixSegment: undefined,\n          suffixSegment: undefined,\n        }\n      }\n\n      // Handle regular pathname segment\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: partToMatch.includes('%25')\n          ? partToMatch\n              .split('%25')\n              .map((segment) => decodeURI(segment))\n              .join('%25')\n          : decodeURI(partToMatch),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n  parseCache?: ParsePathnameCache\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path, parseCache)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (key === '*' || key === '_splat') {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value\n      }\n\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat\n\n        // TODO: Deprecate *\n        usedParams['*'] = params._splat\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if _splat parameter is missing\n        if (!('_splat' in params)) {\n          isMissingParams = true\n          // For missing splat parameters, just return the prefix and suffix without the wildcard\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`\n          }\n          // If there is a prefix or suffix, return them joined, otherwise omit the segment\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          return undefined\n        }\n\n        const value = encodeParam('_splat')\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? 'undefined'}${segmentSuffix}`\n      }\n\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1)\n\n        const segmentPrefix = segment.prefixSegment || ''\n        const segmentSuffix = segment.suffixSegment || ''\n\n        // Check if optional parameter is missing or undefined\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`\n          }\n          // For optional params with prefix/suffix, keep the prefix/suffix but omit the param\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`\n          }\n          // If no prefix/suffix, omit the entire segment\n          return undefined\n        }\n\n        usedParams[key] = params[key]\n\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segmentPrefix}${segment.value}${value ?? ''}${segmentSuffix}`\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? ''}${segmentSuffix}`\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? ''}${segmentSuffix}`\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n  parseCache?: ParsePathnameCache,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(\n    basepath,\n    currentPathname,\n    matchLocation,\n    parseCache,\n  )\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(\n  basepath: string,\n  pathname: string,\n  caseSensitive: boolean = false,\n) {\n  // normalize basepath and pathname for case-insensitive comparison if needed\n  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase()\n  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase()\n\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case normalizedBasepath === '/':\n      return pathname\n\n    // shortcut for removing the basepath if it matches the pathname\n    case normalizedPathname === normalizedBasepath:\n      return ''\n\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname\n\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case normalizedPathname[normalizedBasepath.length] !== '/':\n      return pathname\n\n    // remove the basepath from the pathname if it starts with it\n    case normalizedPathname.startsWith(normalizedBasepath):\n      return pathname.slice(basepath.length)\n\n    // otherwise, return the pathname as is\n    default:\n      return pathname\n  }\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  {\n    to,\n    fuzzy,\n    caseSensitive,\n  }: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n  parseCache?: ParsePathnameCache,\n): Record<string, string> | undefined {\n  // check basepath first\n  if (basepath !== '/' && !from.startsWith(basepath)) {\n    return undefined\n  }\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from, caseSensitive)\n  // Default to to $ (wildcard)\n  to = removeBasepath(basepath, `${to ?? '$'}`, caseSensitive)\n\n  // Parse the from and to\n  const baseSegments = parsePathname(\n    from.startsWith('/') ? from : `/${from}`,\n    parseCache,\n  )\n  const routeSegments = parsePathname(\n    to.startsWith('/') ? to : `/${to}`,\n    parseCache,\n  )\n\n  const params: Record<string, string> = {}\n\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive,\n  )\n\n  return result ? params : undefined\n}\n\nfunction isMatch(\n  baseSegments: ReadonlyArray<Segment>,\n  routeSegments: ReadonlyArray<Segment>,\n  params: Record<string, string>,\n  fuzzy?: boolean,\n  caseSensitive?: boolean,\n): boolean {\n  let baseIndex = 0\n  let routeIndex = 0\n  let processedOptionals = 0\n\n  const optionalCount = routeSegments.filter(\n    (seg) => seg.type === SEGMENT_TYPE_OPTIONAL_PARAM,\n  ).length\n\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex]\n    const routeSegment = routeSegments[routeIndex]\n\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        // Capture all remaining segments for a wildcard\n        const remainingBaseSegments = baseSegments.slice(baseIndex)\n\n        let _splat: string\n\n        // If this is a wildcard with prefix/suffix, we need to handle the first segment specially\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false\n\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if ('prefixSegment' in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false\n            }\n          }\n          if ('suffixSegment' in routeSegment) {\n            if (\n              !baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)\n            ) {\n              return false\n            }\n          }\n\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n\n          // Remove the prefix and suffix from the rejoined splat\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length)\n          }\n\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length,\n            )\n          }\n\n          _splat = rejoinedSplat\n        } else {\n          // If no prefix/suffix, just rejoin the remaining segments\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value)),\n          )\n        }\n\n        // TODO: Deprecate *\n        params['*'] = _splat\n        params['_splat'] = _splat\n        return true\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === '/' && !baseSegment?.value) {\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          } else if (\n            routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()\n          ) {\n            return false\n          }\n          baseIndex++\n          routeIndex++\n          continue\n        } else {\n          return false\n        }\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false\n        }\n\n        if (baseSegment.value === '/') {\n          return false\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false\n          }\n\n          let paramValue = baseValue\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length)\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length)\n          }\n\n          _paramValue = decodeURIComponent(paramValue)\n          matched = true\n        } else {\n          // If no prefix/suffix, just decode the base segment value\n          _paramValue = decodeURIComponent(baseSegment.value)\n          matched = true\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        routeIndex++\n        continue\n      }\n\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        // Optional parameters can be missing - don't fail the match\n        if (!baseSegment) {\n          // No base segment for optional param - skip this route segment\n          processedOptionals++\n\n          routeIndex++\n          continue\n        }\n\n        if (baseSegment.value === '/') {\n          // Skip slash segments for optional params\n          processedOptionals++\n\n          routeIndex++\n          continue\n        }\n\n        let _paramValue = ''\n        let matched = false\n\n        // If this optional param has prefix/suffix, we need to extract the actual parameter value\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || ''\n          const suffix = routeSegment.suffixSegment || ''\n\n          // Check if the base segment starts with prefix and ends with suffix\n          const baseValue = baseSegment.value\n          if (\n            (!prefix || baseValue.startsWith(prefix)) &&\n            (!suffix || baseValue.endsWith(suffix))\n          ) {\n            let paramValue = baseValue\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length)\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length,\n              )\n            }\n\n            _paramValue = decodeURIComponent(paramValue)\n            matched = true\n          }\n        } else {\n          // For optional params without prefix/suffix, we need to check if the current\n          // base segment should match this optional param or a later route segment\n\n          let shouldMatchOptional = true\n          const remainingOptionals = optionalCount - processedOptionals - 1 > 0\n\n          // consider last route segment might be index route and any prior optionals that was not matched\n          const remainingRouteSegmentLength =\n            (routeSegments.slice(-1)[0]?.value === '/'\n              ? routeSegments.length - 1\n              : routeSegments.length) - routeIndex\n\n          const remainingRequiredRouteSegmentCount =\n            remainingRouteSegmentLength - (optionalCount - processedOptionals)\n          const remainingBaseSegmentCount = baseSegments.length - baseIndex\n\n          // Look ahead to see if there's a later route segment that matches the current base segment\n          for (\n            let lookAhead = routeIndex + 1;\n            lookAhead < routeSegments.length;\n            lookAhead++\n          ) {\n            const futureRouteSegment = routeSegments[lookAhead]\n\n            // where the next segment is a required path name, we can break early.\n            // either the current base segment matches a future pathname segment,\n            // in which case we should skip this optional parameter,\n            // or the url is invalid\n            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME) {\n              if (\n                caseSensitive\n                  ? futureRouteSegment.value === baseSegment.value\n                  : futureRouteSegment.value.toLowerCase() ===\n                    baseSegment.value.toLowerCase()\n              ) {\n                // so we should skip this optional parameter\n                shouldMatchOptional = false\n              }\n              break\n            }\n\n            // where consecutive optional params are used, we can break early.\n            // preference is given to the first optional param\n            if (futureRouteSegment?.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n              if (\n                remainingRequiredRouteSegmentCount >= remainingBaseSegmentCount\n              ) {\n                shouldMatchOptional = false\n              }\n              break\n            }\n\n            // this if is not required for the rest of the logic, but it's useful to know what type of future segment we're looking at'\n            if (\n              futureRouteSegment?.type === SEGMENT_TYPE_PARAM ||\n              futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD\n            ) {\n              const followingRouteSegment = routeSegments[lookAhead + 1]\n\n              let isMatchedFurtherDown = false\n\n              // since we know there are remaining optionals, we look to the segment following the next.\n              // if further segments are required paths, then we can possibly match further optionals based on the url pattern. to do this, we match the remaining paths\n              // if all that follows are wildcards/required params and/or optionals params we continue matching on a first-case basis, and optionals further down are unmatched.\n              if (\n                remainingOptionals &&\n                followingRouteSegment &&\n                (followingRouteSegment.type === SEGMENT_TYPE_PATHNAME ||\n                  (followingRouteSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM &&\n                    (followingRouteSegment.prefixSegment ||\n                      followingRouteSegment.suffixSegment)))\n              ) {\n                const remainingRouteSegments = routeSegments.slice(\n                  lookAhead + 1,\n                )\n\n                const remainingRouteSegmentLength =\n                  remainingRouteSegments.slice(-1)[0]?.value === '/'\n                    ? remainingRouteSegments.length - 1\n                    : remainingRouteSegments.length\n\n                const remainingBaseSegments = baseSegments.slice(baseIndex + 1)\n\n                isMatchedFurtherDown =\n                  remainingRouteSegmentLength ===\n                    remainingBaseSegments.length &&\n                  isMatch(\n                    remainingBaseSegments,\n                    remainingRouteSegments,\n                    { ...params },\n                    fuzzy,\n                    caseSensitive,\n                  )\n              }\n\n              if (\n                !remainingOptionals ||\n                // remaining required segments equals remaining base segments\n                remainingRequiredRouteSegmentCount ===\n                  remainingBaseSegmentCount ||\n                // matched by probe further down\n                isMatchedFurtherDown\n              ) {\n                if (remainingBaseSegmentCount < remainingRouteSegmentLength) {\n                  shouldMatchOptional = false\n                }\n                break\n              }\n            }\n          }\n\n          if (shouldMatchOptional) {\n            // If no prefix/suffix, just decode the base segment value\n            _paramValue = decodeURIComponent(baseSegment.value)\n            matched = true\n          }\n        }\n\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue\n          baseIndex++\n        }\n\n        processedOptionals++\n\n        routeIndex++\n        continue\n      }\n    }\n\n    // If we have base segments left but no route segments, it's a fuzzy match\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params['**'] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value),\n      )\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== '/'\n    }\n\n    // If we have route segments left but no base segments, check if remaining are optional\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      // Check if all remaining route segments are optional\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false\n        }\n      }\n      // All remaining are optional, so we can finish\n      break\n    }\n\n    break\n  }\n\n  return true\n}\n"],"names":["remainingRouteSegmentLength"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/esm/router.d.ts b/dist/esm/router.d.ts
index d9ccd39c28caff517fec554eff3048ad2ab3871b..daa5907cd5f3048c8d427b88ea2fdcfeef3744a9 100644
--- a/dist/esm/router.d.ts
+++ b/dist/esm/router.d.ts
@@ -662,7 +662,7 @@ export declare function getInitialRouterState(location: ParsedLocation): RouterS
  * Build the matched route chain and extract params for a pathname.
  * Falls back to the root route if no specific route is found.
  */
-export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ pathname, routePathname, caseSensitive, routesByPath, routesById, flatRoutes, parseCache, }: {
+export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ basepath, pathname, routePathname, caseSensitive, routesByPath, routesById, flatRoutes, parseCache, }: {
     pathname: string;
     routePathname?: string;
     caseSensitive?: boolean;
@@ -670,6 +670,7 @@ export declare function getMatchedRoutes<TRouteLike extends RouteLike>({ pathnam
     routesById: Record<string, TRouteLike>;
     flatRoutes: Array<TRouteLike>;
     parseCache?: ParsePathnameCache;
+    basepath?: string;
 }): {
     matchedRoutes: TRouteLike[];
     routeParams: Record<string, string>;
diff --git a/dist/esm/router.js b/dist/esm/router.js
index 7bac777890e859f17664f4db99d757276d36a4e8..efc605ca09f43b782fc913ac868d5c972ab66792 100644
--- a/dist/esm/router.js
+++ b/dist/esm/router.js
@@ -233,7 +233,8 @@ class RouterCore {
         base: from,
         to: cleanPath(path),
         trailingSlash: this.options.trailingSlash,
-        parseCache: this.parsePathnameCache
+        parseCache: this.parsePathnameCache,
+        basepath: this.basepath
       });
       return resolvedPath;
     };
@@ -252,6 +253,7 @@ class RouterCore {
     this.parsePathnameCache = createLRUCache(1e3);
     this.getMatchedRoutes = (pathname, routePathname) => {
       return getMatchedRoutes({
+        basepath: this.basepath,
         pathname,
         routePathname,
         caseSensitive: this.options.caseSensitive,
@@ -385,6 +387,7 @@ class RouterCore {
           let params = {};
           const foundMask = this.options.routeMasks?.find((d) => {
             const match = matchPathname(
+              this.basepath,
               next.pathname,
               {
                 to: d.from,
@@ -903,6 +906,7 @@ class RouterCore {
       const pending = opts?.pending === void 0 ? !this.state.isLoading : opts.pending;
       const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;
       const match = matchPathname(
+        this.basepath,
         baseLocation.pathname,
         {
           ...opts,
@@ -1203,6 +1207,7 @@ function validateSearch(validateSearch2, input) {
   return {};
 }
 function getMatchedRoutes({
+  basepath = "/",
   pathname,
   routePathname,
   caseSensitive,
@@ -1215,6 +1220,7 @@ function getMatchedRoutes({
   const trimmedPath = trimPathRight(pathname);
   const getMatchedParams = (route) => {
     const result = matchPathname(
+      basepath,
       trimmedPath,
       {
         to: route.fullPath,
diff --git a/dist/esm/router.js.map b/dist/esm/router.js.map
index 69ab62e094fe6f84175505223d307c96fe4f1380..1c642adc04efae5f91c2fb8da1a356d1369c8e44 100644
--- a/dist/esm/router.js.map
+++ b/dist/esm/router.js.map
@@ -1 +1 @@
-{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import { Store, batch } from '@tanstack/store'\nimport { createBrowserHistory, parseHref } from '@tanstack/history'\nimport {\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  last,\n  replaceEqualDeep,\n} from './utils'\nimport { processRouteTree } from './process-route-tree'\nimport {\n  cleanPath,\n  interpolatePath,\n  matchPathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, redirect } from './redirect'\nimport { createLRUCache } from './lru-cache'\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from './load-matches'\nimport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath,\n} from './rewrite'\nimport type { ParsePathnameCache } from './path'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  Awaitable,\n  Constrain,\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteLike,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest } from './manifest'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\nimport type {\n  AnySerializationAdapter,\n  ValidateSerializableInput,\n} from './ssr/serializer/transformer'\n// import type { AnyRouterConfig } from './config'\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // Lots of things on here like...\n  // router\n  // config\n  // ssr\n}\n\nexport type RegisteredSsr<TRegister = Register> = TRegister extends {\n  ssr: infer TSSR\n}\n  ? TSSR\n  : false\n\nexport type RegisteredRouter<TRegister = Register> = TRegister extends {\n  router: infer TRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type RegisteredConfigType<TRegister, TKey> = TRegister extends {\n  config: infer TConfig\n}\n  ? TConfig extends {\n      '~types': infer TTypes\n    }\n    ? TKey extends keyof TTypes\n      ? TTypes[TKey]\n      : unknown\n    : unknown\n  : unknown\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport type SSROption = boolean | 'data-only'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated = undefined,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `preloadIntentProximity` a route should use if no preloadIntentProximity is provided.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadintentproximity-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-intent-proximity)\n   */\n  defaultPreloadIntentProximity?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * ```\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n\n  additionalContext?: any\n\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => Constrain<\n    TDehydrated,\n    ValidateSerializableInput<Register, TDehydrated>\n  >\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => Awaitable<void>\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  /**\n   * @default false\n   */\n  isShell?: boolean\n\n  /**\n   * @default false\n   */\n  isPrerendering?: boolean\n\n  /**\n   * The default `ssr` a route should use if no `ssr` is provided.\n   *\n   * @default true\n   */\n  defaultSsr?: SSROption\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?:\n    | boolean\n    | ((opts: { location: ParsedLocation }) => boolean)\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n\n  /**\n   * When `true`, disables the global catch boundary that normally wraps all route matches.\n   * This allows unhandled errors to bubble up to top-level error handlers in the browser.\n   *\n   * Useful for testing tools (like Storybook Test Runner), error reporting services,\n   * and debugging scenarios where you want errors to reach the browser's global error handlers.\n   *\n   * @default false\n   */\n  disableGlobalCatchBoundary?: boolean\n\n  serializationAdapters?: ReadonlyArray<AnySerializationAdapter>\n  /**\n   * Configures how the router will rewrite the location between the actual href and the internal href of the router.\n   *\n   * @default undefined\n   * @description You can provide a custom rewrite pair (in/out).\n   * This is useful for shifting data from the origin to the path (for things like subdomain routing), or other advanced use cases.\n   */\n  rewrite?: LocationRewrite\n  origin?: string\n  ssr?: {\n    nonce?: string\n  }\n}\n\nexport type LocationRewrite = {\n  /**\n   * A function that will be called to rewrite the URL before it is interpreted by the router from the history instance.\n   *\n   * @default undefined\n   */\n  input?: LocationRewriteFunction\n  /**\n   * A function that will be called to rewrite the URL before it is committed to the actual history instance from the router.\n   *\n   * @default undefined\n   */\n  output?: LocationRewriteFunction\n}\n\n/**\n * A function that will be called to rewrite the URL.\n *\n * @param url The URL to rewrite.\n * @returns The rewritten URL (as a URL instance or full href string) or undefined if no rewrite is needed.\n */\nexport type LocationRewriteFunction = ({\n  url,\n}: {\n  url: URL\n}) => undefined | string | URL\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: AnyRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  href?: string\n  _fromLocation?: ParsedLocation\n  unsafeRelative?: 'path'\n  _isNavigate?: boolean\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport interface RouterEvents {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context' | 'serializationAdapters' | 'defaultSsr'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n  forcePending?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  locationToParse: HistoryLocation,\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  pathname: string,\n  routePathname: string | undefined,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch?: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<MakeRouteMatchUnion>\n  /**\n   * @deprecated use the following signature instead\n   */\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => void\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSsr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  isDehydrated: () => boolean\n  onRenderFinished: (listener: () => void) => void\n  dehydrate: () => Promise<void>\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string> | false)\n}\n\n// TODO where is this used? can we remove this?\n/**\n * Convert an unknown error into a minimal, serializable object.\n * Includes name and message (and stack in development).\n */\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n\n/** Options for configuring trailing-slash behavior. */\nexport const trailingSlashOptions = {\n  always: 'always',\n  never: 'never',\n  preserve: 'preserve',\n} as const\n\nexport type TrailingSlashOption =\n  (typeof trailingSlashOptions)[keyof typeof trailingSlashOptions]\n\n/**\n * Compute whether path, href or hash changed between previous and current\n * resolved locations in router state.\n */\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\n/**\n * Core, framework-agnostic router engine that powers TanStack Router.\n *\n * Provides navigation, matching, loading, preloading, caching and event APIs\n * used by framework adapters (React/Solid). Prefer framework helpers like\n * `createRouter` in app code.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType\n */\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  rewrite?: LocationRewrite\n  origin?: string\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      self.__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  isShell() {\n    return !!this.options.isShell\n  }\n\n  isPrerendering() {\n    return !!this.options.isPrerendering\n  }\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const prevOptions = this.options\n    const prevBasepath = this.basepath ?? prevOptions?.basepath ?? '/'\n    const basepathWasUnset = this.basepath === undefined\n    const prevRewriteOption = prevOptions?.rewrite\n\n    this.options = {\n      ...prevOptions,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (!this.options.history) {\n        if (!this.isServer) {\n          this.history = createBrowserHistory() as TRouterHistory\n        }\n      } else {\n        this.history = this.options.history\n      }\n    }\n\n    this.origin = this.options.origin\n    if (!this.origin) {\n      if (!this.isServer && window?.origin && window.origin !== 'null') {\n        this.origin = window.origin\n      } else {\n        // fallback for the server, can be overridden by calling router.update({origin}) on the server\n        this.origin = 'http://localhost'\n      }\n    }\n\n    if (this.history) {\n      this.updateLatestLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store && this.latestLocation) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    let needsLocationUpdate = false\n    const nextBasepath = this.options.basepath ?? '/'\n    const nextRewriteOption = this.options.rewrite\n    const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath\n    const rewriteChanged = prevRewriteOption !== nextRewriteOption\n\n    if (basepathChanged || rewriteChanged) {\n      this.basepath = nextBasepath\n\n      const rewrites: Array<LocationRewrite> = []\n      if (trimPath(nextBasepath) !== '') {\n        rewrites.push(\n          rewriteBasepath({\n            basepath: nextBasepath,\n          }),\n        )\n      }\n      if (nextRewriteOption) {\n        rewrites.push(nextRewriteOption)\n      }\n\n      this.rewrite =\n        rewrites.length === 0\n          ? undefined\n          : rewrites.length === 1\n            ? rewrites[0]\n            : composeRewrites(rewrites)\n\n      if (this.history) {\n        this.updateLatestLocation()\n      }\n\n      needsLocationUpdate = true\n    }\n\n    if (needsLocationUpdate && this.__store) {\n      this.__store.state = {\n        ...this.state,\n        location: this.latestLocation,\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state(): RouterState<TRouteTree> {\n    return this.__store.state\n  }\n\n  updateLatestLocation = () => {\n    this.latestLocation = this.parseLocation(\n      this.history.location,\n      this.latestLocation,\n    )\n  }\n\n  buildRouteTree = () => {\n    const { routesById, routesByPath, flatRoutes } = processRouteTree({\n      routeTree: this.routeTree,\n      initRoute: (route, i) => {\n        route.init({\n          originalIndex: i,\n        })\n      },\n    })\n\n    this.routesById = routesById as RoutesById<TRouteTree>\n    this.routesByPath = routesByPath as RoutesByPath<TRouteTree>\n    this.flatRoutes = flatRoutes as Array<AnyRoute>\n\n    const notFoundRoute = this.options.notFoundRoute\n\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n      })\n      this.routesById[notFoundRoute.id] = notFoundRoute\n    }\n  }\n\n  /**\n   * Subscribe to router lifecycle events like `onBeforeNavigate`, `onLoad`,\n   * `onResolved`, etc. Returns an unsubscribe function.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType\n   */\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  /**\n   * Parse a HistoryLocation into a strongly-typed ParsedLocation using the\n   * current router options, rewrite rules and search parser/stringifier.\n   */\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    locationToParse,\n    previousLocation,\n  ) => {\n    const parse = ({\n      href,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      // Before we do any processing, we need to allow rewrites to modify the URL\n      // build up the full URL by combining the href from history with the router's origin\n      const fullUrl = new URL(href, this.origin)\n      const url = executeRewriteInput(this.rewrite, fullUrl)\n\n      const parsedSearch = this.options.parseSearch(url.search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n      // Make sure our final url uses the re-stringified pathname, search, and has for consistency\n      // (We were already doing this, so just keeping it for now)\n      url.search = searchStr\n\n      const fullPath = url.href.replace(url.origin, '')\n\n      const { pathname, hash } = url\n\n      return {\n        href: fullPath,\n        publicHref: href,\n        url: url.href,\n        pathname: decodePath(pathname),\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key // TODO: Remove in v2 - use __TSR_key instead\n      parsedTempLocation.state.__TSR_key = location.state.__TSR_key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n    return location\n  }\n\n  /** Resolve a path against the router basepath and trailing-slash policy. */\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      parseCache: this.parsePathnameCache,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    }\n\n    return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next.pathname,\n      opts?.dest?.to as string,\n    )\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? undefined)\n        : (parentMatch.context ?? this.options.context ?? undefined)\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? undefined\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            undefined\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath + loaderDepsHash\n\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const strictParams = existingMatch?._strictParams ?? usedParams\n\n      let paramsError: PathParamError | undefined = undefined\n\n      if (!existingMatch) {\n        const strictParseParams =\n          route.options.params?.parse ?? route.options.parseParams\n\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams as Record<string, string>),\n            )\n          } catch (err: any) {\n            paramsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw paramsError\n            }\n          }\n        }\n      }\n\n      Object.assign(routeParams, strictParams)\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError,\n          __routeContext: undefined,\n          _nonReactive: {\n            loadPromise: createControlledPromise(),\n          },\n          __beforeLoadContext: undefined,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not calling from router.buildLocation\n\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n\n        if (route.options.context) {\n          const contextFnContext: RouteContextOptions<any, any, any, any> = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts: any) =>\n              this.navigate({ ...opts, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches,\n          }\n          // Get the route context\n          match.__routeContext =\n            route.options.context(contextFnContext) ?? undefined\n        }\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n    })\n\n    return matches\n  }\n\n  /** a cache for `parsePathname` */\n  private parsePathnameCache: ParsePathnameCache = createLRUCache(1000)\n\n  getMatchedRoutes: GetMatchRoutesFn = (\n    pathname: string,\n    routePathname: string | undefined,\n  ) => {\n    return getMatchedRoutes({\n      pathname,\n      routePathname,\n      caseSensitive: this.options.caseSensitive,\n      routesByPath: this.routesByPath,\n      routesById: this.routesById,\n      flatRoutes: this.flatRoutes,\n      parseCache: this.parsePathnameCache,\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match._nonReactive.pendingTimeout)\n    match._nonReactive.pendingTimeout = undefined\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  /**\n   * Build the next ParsedLocation from navigation options without committing.\n   * Resolves `to`/`from`, params/search/hash/state, applies search validation\n   * and middlewares, and returns a stable, stringified location object.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType#buildlocation-method\n   */\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n    ): ParsedLocation => {\n      // We allow the caller to override the current location\n      const currentLocation = dest._fromLocation || this.latestLocation\n\n      const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n        _buildLocation: true,\n      })\n\n      // Now let's find the starting pathname\n      // This should default to the current location if no from is provided\n      const lastMatch = last(allCurrentLocationMatches)!\n\n      // check that from path exists in the current route tree\n      // do this check only on navigations during test or development\n      if (\n        dest.from &&\n        process.env.NODE_ENV !== 'production' &&\n        dest._isNavigate\n      ) {\n        const allFromMatches = this.getMatchedRoutes(\n          dest.from,\n          undefined,\n        ).matchedRoutes\n\n        const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n          return comparePaths(d.fullPath, dest.from!)\n        })\n\n        const matchedCurrent = findLast(allFromMatches, (d) => {\n          return comparePaths(d.fullPath, lastMatch.fullPath)\n        })\n\n        // for from to be invalid it shouldn't just be unmatched to currentLocation\n        // but the currentLocation should also be unmatched to from\n        if (!matchedFrom && !matchedCurrent) {\n          console.warn(`Could not find match for from: ${dest.from}`)\n        }\n      }\n\n      const defaultedFromPath =\n        dest.unsafeRelative === 'path'\n          ? currentLocation.pathname\n          : (dest.from ?? lastMatch.fullPath)\n\n      // ensure this includes the basePath if set\n      const fromPath = this.resolvePathWithBase(defaultedFromPath, '.')\n\n      // From search should always use the current location\n      const fromSearch = lastMatch.search\n      // Same with params. It can't hurt to provide as many as possible\n      const fromParams = { ...lastMatch.params }\n\n      // Resolve the next to\n      // ensure this includes the basePath if set\n      const nextTo = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, '.')\n\n      // Resolve the next params\n      const nextParams =\n        dest.params === false || dest.params === null\n          ? {}\n          : (dest.params ?? true) === true\n            ? fromParams\n            : Object.assign(\n                fromParams,\n                functionalUpdate(dest.params as any, fromParams),\n              )\n\n      // Interpolate the path first to get the actual resolved path, then match against that\n      const interpolatedNextTo = interpolatePath({\n        path: nextTo,\n        params: nextParams,\n        parseCache: this.parsePathnameCache,\n      }).interpolatedPath\n\n      const destRoutes = this.matchRoutes(interpolatedNextTo, undefined, {\n        _buildLocation: true,\n      }).map((d) => this.looseRoutesById[d.routeId]!)\n\n      // If there are any params, we need to stringify them\n      if (Object.keys(nextParams).length > 0) {\n        for (const route of destRoutes) {\n          const fn =\n            route.options.params?.stringify ?? route.options.stringifyParams\n          if (fn) {\n            Object.assign(nextParams, fn(nextParams))\n          }\n        }\n      }\n\n      const nextPathname = decodePath(\n        interpolatePath({\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          path: nextTo,\n          params: nextParams,\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath,\n      )\n\n      // Resolve the next search\n      let nextSearch = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        const validatedSearch = {}\n        destRoutes.forEach((route) => {\n          if (route.options.validateSearch) {\n            try {\n              Object.assign(\n                validatedSearch,\n                validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...nextSearch,\n                }),\n              )\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n            }\n          }\n        })\n        nextSearch = validatedSearch\n      }\n\n      nextSearch = applySearchMiddleware({\n        search: nextSearch,\n        dest,\n        destRoutes,\n        _includeValidateSearch: opts._includeValidateSearch,\n      })\n\n      // Replace the equal deep\n      nextSearch = replaceEqualDeep(fromSearch, nextSearch)\n\n      // Stringify the next search\n      const searchStr = this.options.stringifySearch(nextSearch)\n\n      // Resolve the next hash\n      const hash =\n        dest.hash === true\n          ? currentLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, currentLocation.hash)\n            : undefined\n\n      // Resolve the next hash string\n      const hashStr = hash ? `#${hash}` : ''\n\n      // Resolve the next state\n      let nextState =\n        dest.state === true\n          ? currentLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, currentLocation.state)\n            : {}\n\n      // Replace the equal deep\n      nextState = replaceEqualDeep(currentLocation.state, nextState)\n\n      // Create the full path of the location\n      const fullPath = `${nextPathname}${searchStr}${hashStr}`\n\n      // Create the new href with full origin\n      const url = new URL(fullPath, this.origin)\n\n      // If a rewrite function is provided, use it to rewrite the URL\n      const rewrittenUrl = executeRewriteOutput(this.rewrite, url)\n\n      return {\n        publicHref:\n          rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n        href: fullPath,\n        url: rewrittenUrl.href,\n        pathname: nextPathname,\n        search: nextSearch,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(\n            next.pathname,\n            {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            },\n            this.parsePathnameCache,\n          )\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from: _from, ...maskProps } = foundMask\n          maskedDest = {\n            from: opts.from,\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      if (maskedNext) {\n        next.maskedLocation = maskedNext\n      }\n\n      return next\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        from: opts.from,\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  /**\n   * Commit a previously built location to history (push/replace), optionally\n   * using view transitions and scroll restoration options.\n   */\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key', // TODO: Remove in v2 - use __TSR_key instead\n        '__TSR_key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl =\n      trimPathRight(this.latestLocation.href) === trimPathRight(next.href)\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                __TSR_key: undefined!,\n                key: undefined!, // TODO: Remove in v2 - use __TSR_key instead\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  /** Convenience helper: build a location from options, then commit it. */\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n  }\n\n  /**\n   * Imperatively navigate using standard `NavigateOptions`. When `reloadDocument`\n   * or an absolute `href` is provided, performs a full document navigation.\n   * Otherwise, builds and commits a client-side location.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType\n   */\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (!reloadDocument && href) {\n      try {\n        new URL(`${href}`)\n        reloadDocument = true\n      } catch {}\n    }\n\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = location.url\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return Promise.resolve()\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n      _isNavigate: true,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  beforeLoad = () => {\n    // Cancel any pending matches\n    this.cancelMatches()\n    this.updateLatestLocation()\n\n    if (this.isServer) {\n      // for SPAs on the initial load, this is handled by the Transitioner\n      const nextLocation = this.buildLocation({\n        to: this.latestLocation.pathname,\n        search: true,\n        params: true,\n        hash: true,\n        state: true,\n        _includeValidateSearch: true,\n      })\n\n      // Normalize URLs for comparison to handle encoding differences\n      // Browser history always stores encoded URLs while buildLocation may produce decoded URLs\n      const normalizeUrl = (url: string) => {\n        try {\n          return encodeURI(decodeURI(url))\n        } catch {\n          return url\n        }\n      }\n\n      if (\n        trimPath(normalizeUrl(this.latestLocation.href)) !==\n        trimPath(normalizeUrl(nextLocation.href))\n      ) {\n        let href = nextLocation.url\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, '') || '/'\n        }\n\n        throw redirect({ href })\n      }\n    }\n\n    // Match the routes\n    const pendingMatches = this.matchRoutes(this.latestLocation)\n\n    // Ingest the new matches\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'pending',\n      statusCode: 200,\n      isLoading: true,\n      location: this.latestLocation,\n      pendingMatches,\n      // If a cached moved to pendingMatches, remove it from cachedMatches\n      cachedMatches: s.cachedMatches.filter(\n        (d) => !pendingMatches.some((e) => e.id === d.id),\n      ),\n    }))\n  }\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    let redirect: AnyRedirect | undefined\n    let notFound: NotFoundError | undefined\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          this.beforeLoad()\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await loadMatches({\n            router: this,\n            sync: opts?.sync,\n            matches: this.state.pendingMatches as Array<AnyRouteMatch>,\n            location: next,\n            updateMatch: this.updateMatch,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              // Wrap batch in framework-specific transition wrapper (e.g., Solid's startTransition)\n              this.startTransition(() => {\n                this.startViewTransition(async () => {\n                  // this.viewTransitionPromise = createControlledPromise<true>()\n\n                  // Commit the pending matches. If a previous match was\n                  // removed, place it in the cachedMatches\n                  let exitingMatches: Array<AnyRouteMatch> = []\n                  let enteringMatches: Array<AnyRouteMatch> = []\n                  let stayingMatches: Array<AnyRouteMatch> = []\n\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches\n                      const newMatches = s.pendingMatches || s.matches\n\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id),\n                      )\n                      enteringMatches = newMatches.filter(\n                        (match) =>\n                          !previousMatches.some((d) => d.id === match.id),\n                      )\n                      stayingMatches = newMatches.filter((match) =>\n                        previousMatches.some((d) => d.id === match.id),\n                      )\n\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: undefined,\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter((d) => d.status !== 'error'),\n                        ],\n                      }\n                    })\n                    this.clearExpiredCache()\n                  })\n\n                  //\n                  ;(\n                    [\n                      [exitingMatches, 'onLeave'],\n                      [enteringMatches, 'onEnter'],\n                      [stayingMatches, 'onStay'],\n                    ] as const\n                  ).forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId]!.options[hook]?.(\n                        match,\n                      )\n                    })\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect.options,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.status\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    let newStatusCode: number | undefined = undefined\n    if (this.hasNotFoundMatch()) {\n      newStatusCode = 404\n    } else if (this.__store.state.matches.some((d) => d.status === 'error')) {\n      newStatusCode = 500\n    }\n    if (newStatusCode !== undefined) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: newStatusCode,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        if (resolvedViewTransitionTypes === false) {\n          fn()\n          return\n        }\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    const matchesKey = this.state.pendingMatches?.some((d) => d.id === id)\n      ? 'pendingMatches'\n      : this.state.matches.some((d) => d.id === id)\n        ? 'matches'\n        : this.state.cachedMatches.some((d) => d.id === id)\n          ? 'cachedMatches'\n          : ''\n\n    if (matchesKey) {\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) => (d.id === id ? updater(d) : d)),\n      }))\n    }\n  }\n\n  getMatch: GetMatchFn = (matchId: string) => {\n    const findFn = (d: { id: string }) => d.id === matchId\n    return (\n      this.state.cachedMatches.find(findFn) ??\n      this.state.pendingMatches?.find(findFn) ??\n      this.state.matches.find(findFn)\n    )\n  }\n\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(opts?.forcePending || d.status === 'error'\n            ? ({ status: 'pending', error: undefined } as const)\n            : undefined),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.shouldViewTransition = false\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (redirect: AnyRedirect): AnyRedirect => {\n    if (!redirect.options.href) {\n      const location = this.buildLocation(redirect.options)\n      let href = location.url\n      if (this.origin && href.startsWith(this.origin)) {\n        href = href.replace(this.origin, '') || '/'\n      }\n      redirect.options.href = location.href\n      redirect.headers.set('Location', href)\n    }\n    if (!redirect.headers.get('Location')) {\n      redirect.headers.set('Location', redirect.options.href)\n    }\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      const isError = d.status === 'error'\n      if (isError) return true\n\n      const gcEligible = Date.now() - d.updatedAt >= gcTime\n      return gcEligible\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = loadRouteChunk\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await loadMatches({\n        router: this,\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.options.reloadDocument) {\n          return undefined\n        }\n\n        return await this.preloadRoute({\n          ...err.options,\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = matchPathname(\n      baseLocation.pathname,\n      {\n        ...opts,\n        to: next.pathname,\n      },\n      this.parsePathnameCache,\n    ) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match\n        : false\n    }\n\n    return match\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n  }\n\n  serverSsr?: ServerSsr\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n/** Error thrown when search parameter validation fails. */\nexport class SearchParamError extends Error {}\n\n/** Error thrown when path parameter parsing/validation fails. */\nexport class PathParamError extends Error {}\n\nconst normalize = (str: string) =>\n  str.endsWith('/') && str.length > 1 ? str.slice(0, -1) : str\nfunction comparePaths(a: string, b: string) {\n  return normalize(a) === normalize(b)\n}\n\n/**\n * Lazily import a module function and forward arguments to it, retaining\n * parameter and return types for the selected export key.\n */\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\n/** Create an initial RouterState from a parsed location. */\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\n/**\n * Build the matched route chain and extract params for a pathname.\n * Falls back to the root route if no specific route is found.\n */\nexport function getMatchedRoutes<TRouteLike extends RouteLike>({\n  pathname,\n  routePathname,\n  caseSensitive,\n  routesByPath,\n  routesById,\n  flatRoutes,\n  parseCache,\n}: {\n  pathname: string\n  routePathname?: string\n  caseSensitive?: boolean\n  routesByPath: Record<string, TRouteLike>\n  routesById: Record<string, TRouteLike>\n  flatRoutes: Array<TRouteLike>\n  parseCache?: ParsePathnameCache\n}) {\n  let routeParams: Record<string, string> = {}\n  const trimmedPath = trimPathRight(pathname)\n  const getMatchedParams = (route: TRouteLike) => {\n    const result = matchPathname(\n      trimmedPath,\n      {\n        to: route.fullPath,\n        caseSensitive: route.options?.caseSensitive ?? caseSensitive,\n        // we need fuzzy matching for `notFoundMode: 'fuzzy'`\n        fuzzy: true,\n      },\n      parseCache,\n    )\n    return result\n  }\n\n  let foundRoute: TRouteLike | undefined =\n    routePathname !== undefined ? routesByPath[routePathname] : undefined\n  if (foundRoute) {\n    routeParams = getMatchedParams(foundRoute)!\n  } else {\n    // iterate over flatRoutes to find the best match\n    // if we find a fuzzy matching route, keep looking for a perfect fit\n    let fuzzyMatch:\n      | { foundRoute: TRouteLike; routeParams: Record<string, string> }\n      | undefined = undefined\n    for (const route of flatRoutes) {\n      const matchedParams = getMatchedParams(route)\n\n      if (matchedParams) {\n        if (\n          route.path !== '/' &&\n          (matchedParams as Record<string, string>)['**']\n        ) {\n          if (!fuzzyMatch) {\n            fuzzyMatch = { foundRoute: route, routeParams: matchedParams }\n          }\n        } else {\n          foundRoute = route\n          routeParams = matchedParams\n          break\n        }\n      }\n    }\n    // did not find a perfect fit, so take the fuzzy matching route if it exists\n    if (!foundRoute && fuzzyMatch) {\n      foundRoute = fuzzyMatch.foundRoute\n      routeParams = fuzzyMatch.routeParams\n    }\n  }\n\n  let routeCursor: TRouteLike = foundRoute || routesById[rootRouteId]!\n\n  const matchedRoutes: Array<TRouteLike> = [routeCursor]\n\n  while (routeCursor.parentRoute) {\n    routeCursor = routeCursor.parentRoute as TRouteLike\n    matchedRoutes.push(routeCursor)\n  }\n  matchedRoutes.reverse()\n\n  return { matchedRoutes, routeParams, foundRoute }\n}\n\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch,\n}: {\n  search: any\n  dest: BuildNextOptions\n  destRoutes: Array<AnyRoute>\n  _includeValidateSearch: boolean | undefined\n}) {\n  const allMiddlewares =\n    destRoutes.reduce(\n      (acc, route) => {\n        const middlewares: Array<SearchMiddleware<any>> = []\n\n        if ('search' in route.options) {\n          if (route.options.search?.middlewares) {\n            middlewares.push(...route.options.search.middlewares)\n          }\n        }\n        // TODO remove preSearchFilters and postSearchFilters in v2\n        else if (\n          route.options.preSearchFilters ||\n          route.options.postSearchFilters\n        ) {\n          const legacyMiddleware: SearchMiddleware<any> = ({\n            search,\n            next,\n          }) => {\n            let nextSearch = search\n\n            if (\n              'preSearchFilters' in route.options &&\n              route.options.preSearchFilters\n            ) {\n              nextSearch = route.options.preSearchFilters.reduce(\n                (prev, next) => next(prev),\n                search,\n              )\n            }\n\n            const result = next(nextSearch)\n\n            if (\n              'postSearchFilters' in route.options &&\n              route.options.postSearchFilters\n            ) {\n              return route.options.postSearchFilters.reduce(\n                (prev, next) => next(prev),\n                result,\n              )\n            }\n\n            return result\n          }\n          middlewares.push(legacyMiddleware)\n        }\n\n        if (_includeValidateSearch && route.options.validateSearch) {\n          const validate: SearchMiddleware<any> = ({ search, next }) => {\n            const result = next(search)\n            try {\n              const validatedSearch = {\n                ...result,\n                ...(validateSearch(route.options.validateSearch, result) ??\n                  undefined),\n              }\n              return validatedSearch\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n              return result\n            }\n          }\n\n          middlewares.push(validate)\n        }\n\n        return acc.concat(middlewares)\n      },\n      [] as Array<SearchMiddleware<any>>,\n    ) ?? []\n\n  // the chain ends here since `next` is not called\n  const final: SearchMiddleware<any> = ({ search }) => {\n    if (!dest.search) {\n      return {}\n    }\n    if (dest.search === true) {\n      return search\n    }\n    return functionalUpdate(dest.search, search)\n  }\n\n  allMiddlewares.push(final)\n\n  const applyNext = (index: number, currentSearch: any): any => {\n    // no more middlewares left, return the current search\n    if (index >= allMiddlewares.length) {\n      return currentSearch\n    }\n\n    const middleware = allMiddlewares[index]!\n\n    const next = (newSearch: any): any => {\n      return applyNext(index + 1, newSearch)\n    }\n\n    return middleware({ search: currentSearch, next })\n  }\n\n  // Start applying middlewares\n  return applyNext(0, search)\n}\n"],"names":["redirect","opts","validateSearch","search","next"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import { Store, batch } from '@tanstack/store'\nimport { createBrowserHistory, parseHref } from '@tanstack/history'\nimport {\n  createControlledPromise,\n  decodePath,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  last,\n  replaceEqualDeep,\n} from './utils'\nimport { processRouteTree } from './process-route-tree'\nimport {\n  cleanPath,\n  interpolatePath,\n  matchPathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, redirect } from './redirect'\nimport { createLRUCache } from './lru-cache'\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from './load-matches'\nimport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath,\n} from './rewrite'\nimport type { ParsePathnameCache } from './path'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  Awaitable,\n  Constrain,\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteLike,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest } from './manifest'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\nimport type {\n  AnySerializationAdapter,\n  ValidateSerializableInput,\n} from './ssr/serializer/transformer'\n// import type { AnyRouterConfig } from './config'\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface Register {\n  // Lots of things on here like...\n  // router\n  // config\n  // ssr\n}\n\nexport type RegisteredSsr<TRegister = Register> = TRegister extends {\n  ssr: infer TSSR\n}\n  ? TSSR\n  : false\n\nexport type RegisteredRouter<TRegister = Register> = TRegister extends {\n  router: infer TRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type RegisteredConfigType<TRegister, TKey> = TRegister extends {\n  config: infer TConfig\n}\n  ? TConfig extends {\n      '~types': infer TTypes\n    }\n    ? TKey extends keyof TTypes\n      ? TTypes[TKey]\n      : unknown\n    : unknown\n  : unknown\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport type SSROption = boolean | 'data-only'\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated = undefined,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `preloadIntentProximity` a route should use if no preloadIntentProximity is provided.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadintentproximity-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-intent-proximity)\n   */\n  defaultPreloadIntentProximity?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   * ```\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n\n  additionalContext?: any\n\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => Constrain<\n    TDehydrated,\n    ValidateSerializableInput<Register, TDehydrated>\n  >\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => Awaitable<void>\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  /**\n   * @default false\n   */\n  isShell?: boolean\n\n  /**\n   * @default false\n   */\n  isPrerendering?: boolean\n\n  /**\n   * The default `ssr` a route should use if no `ssr` is provided.\n   *\n   * @default true\n   */\n  defaultSsr?: SSROption\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?:\n    | boolean\n    | ((opts: { location: ParsedLocation }) => boolean)\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n\n  /**\n   * When `true`, disables the global catch boundary that normally wraps all route matches.\n   * This allows unhandled errors to bubble up to top-level error handlers in the browser.\n   *\n   * Useful for testing tools (like Storybook Test Runner), error reporting services,\n   * and debugging scenarios where you want errors to reach the browser's global error handlers.\n   *\n   * @default false\n   */\n  disableGlobalCatchBoundary?: boolean\n\n  serializationAdapters?: ReadonlyArray<AnySerializationAdapter>\n  /**\n   * Configures how the router will rewrite the location between the actual href and the internal href of the router.\n   *\n   * @default undefined\n   * @description You can provide a custom rewrite pair (in/out).\n   * This is useful for shifting data from the origin to the path (for things like subdomain routing), or other advanced use cases.\n   */\n  rewrite?: LocationRewrite\n  origin?: string\n  ssr?: {\n    nonce?: string\n  }\n}\n\nexport type LocationRewrite = {\n  /**\n   * A function that will be called to rewrite the URL before it is interpreted by the router from the history instance.\n   *\n   * @default undefined\n   */\n  input?: LocationRewriteFunction\n  /**\n   * A function that will be called to rewrite the URL before it is committed to the actual history instance from the router.\n   *\n   * @default undefined\n   */\n  output?: LocationRewriteFunction\n}\n\n/**\n * A function that will be called to rewrite the URL.\n *\n * @param url The URL to rewrite.\n * @returns The rewritten URL (as a URL instance or full href string) or undefined if no rewrite is needed.\n */\nexport type LocationRewriteFunction = ({\n  url,\n}: {\n  url: URL\n}) => undefined | string | URL\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: AnyRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  href?: string\n  _fromLocation?: ParsedLocation\n  unsafeRelative?: 'path'\n  _isNavigate?: boolean\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport interface RouterEvents {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context' | 'serializationAdapters' | 'defaultSsr'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n  forcePending?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  locationToParse: HistoryLocation,\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  pathname: string,\n  routePathname: string | undefined,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch?: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<MakeRouteMatchUnion>\n  /**\n   * @deprecated use the following signature instead\n   */\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => void\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSsr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  isDehydrated: () => boolean\n  onRenderFinished: (listener: () => void) => void\n  dehydrate: () => Promise<void>\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string> | false)\n}\n\n// TODO where is this used? can we remove this?\n/**\n * Convert an unknown error into a minimal, serializable object.\n * Includes name and message (and stack in development).\n */\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\n\n/** Options for configuring trailing-slash behavior. */\nexport const trailingSlashOptions = {\n  always: 'always',\n  never: 'never',\n  preserve: 'preserve',\n} as const\n\nexport type TrailingSlashOption =\n  (typeof trailingSlashOptions)[keyof typeof trailingSlashOptions]\n\n/**\n * Compute whether path, href or hash changed between previous and current\n * resolved locations in router state.\n */\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\n/**\n * Core, framework-agnostic router engine that powers TanStack Router.\n *\n * Provides navigation, matching, loading, preloading, caching and event APIs\n * used by framework adapters (React/Solid). Prefer framework helpers like\n * `createRouter` in app code.\n *\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType\n */\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  rewrite?: LocationRewrite\n  origin?: string\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      self.__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  isShell() {\n    return !!this.options.isShell\n  }\n\n  isPrerendering() {\n    return !!this.options.isPrerendering\n  }\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const prevOptions = this.options\n    const prevBasepath = this.basepath ?? prevOptions?.basepath ?? '/'\n    const basepathWasUnset = this.basepath === undefined\n    const prevRewriteOption = prevOptions?.rewrite\n\n    this.options = {\n      ...prevOptions,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (!this.options.history) {\n        if (!this.isServer) {\n          this.history = createBrowserHistory() as TRouterHistory\n        }\n      } else {\n        this.history = this.options.history\n      }\n    }\n\n    this.origin = this.options.origin\n    if (!this.origin) {\n      if (!this.isServer && window?.origin && window.origin !== 'null') {\n        this.origin = window.origin\n      } else {\n        // fallback for the server, can be overridden by calling router.update({origin}) on the server\n        this.origin = 'http://localhost'\n      }\n    }\n\n    if (this.history) {\n      this.updateLatestLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store && this.latestLocation) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    let needsLocationUpdate = false\n    const nextBasepath = this.options.basepath ?? '/'\n    const nextRewriteOption = this.options.rewrite\n    const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath\n    const rewriteChanged = prevRewriteOption !== nextRewriteOption\n\n    if (basepathChanged || rewriteChanged) {\n      this.basepath = nextBasepath\n\n      const rewrites: Array<LocationRewrite> = []\n      if (trimPath(nextBasepath) !== '') {\n        rewrites.push(\n          rewriteBasepath({\n            basepath: nextBasepath,\n          }),\n        )\n      }\n      if (nextRewriteOption) {\n        rewrites.push(nextRewriteOption)\n      }\n\n      this.rewrite =\n        rewrites.length === 0\n          ? undefined\n          : rewrites.length === 1\n            ? rewrites[0]\n            : composeRewrites(rewrites)\n\n      if (this.history) {\n        this.updateLatestLocation()\n      }\n\n      needsLocationUpdate = true\n    }\n\n    if (needsLocationUpdate && this.__store) {\n      this.__store.state = {\n        ...this.state,\n        location: this.latestLocation,\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state(): RouterState<TRouteTree> {\n    return this.__store.state\n  }\n\n  updateLatestLocation = () => {\n    this.latestLocation = this.parseLocation(\n      this.history.location,\n      this.latestLocation,\n    )\n  }\n\n  buildRouteTree = () => {\n    const { routesById, routesByPath, flatRoutes } = processRouteTree({\n      routeTree: this.routeTree,\n      initRoute: (route, i) => {\n        route.init({\n          originalIndex: i,\n        })\n      },\n    })\n\n    this.routesById = routesById as RoutesById<TRouteTree>\n    this.routesByPath = routesByPath as RoutesByPath<TRouteTree>\n    this.flatRoutes = flatRoutes as Array<AnyRoute>\n\n    const notFoundRoute = this.options.notFoundRoute\n\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n      })\n      this.routesById[notFoundRoute.id] = notFoundRoute\n    }\n  }\n\n  /**\n   * Subscribe to router lifecycle events like `onBeforeNavigate`, `onLoad`,\n   * `onResolved`, etc. Returns an unsubscribe function.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterEventsType\n   */\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  /**\n   * Parse a HistoryLocation into a strongly-typed ParsedLocation using the\n   * current router options, rewrite rules and search parser/stringifier.\n   */\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    locationToParse,\n    previousLocation,\n  ) => {\n    const parse = ({\n      href,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      // Before we do any processing, we need to allow rewrites to modify the URL\n      // build up the full URL by combining the href from history with the router's origin\n      const fullUrl = new URL(href, this.origin)\n      const url = executeRewriteInput(this.rewrite, fullUrl)\n\n      const parsedSearch = this.options.parseSearch(url.search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n      // Make sure our final url uses the re-stringified pathname, search, and has for consistency\n      // (We were already doing this, so just keeping it for now)\n      url.search = searchStr\n\n      const fullPath = url.href.replace(url.origin, '')\n\n      const { pathname, hash } = url\n\n      return {\n        href: fullPath,\n        publicHref: href,\n        url: url.href,\n        pathname: decodePath(pathname),\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key // TODO: Remove in v2 - use __TSR_key instead\n      parsedTempLocation.state.__TSR_key = location.state.__TSR_key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n    return location\n  }\n\n  /** Resolve a path against the router basepath and trailing-slash policy. */\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      parseCache: this.parsePathnameCache,\n      basepath: this.basepath,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    }\n\n    return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next.pathname,\n      opts?.dest?.to as string,\n    )\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? undefined)\n        : (parentMatch.context ?? this.options.context ?? undefined)\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? undefined\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            undefined\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath + loaderDepsHash\n\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const strictParams = existingMatch?._strictParams ?? usedParams\n\n      let paramsError: PathParamError | undefined = undefined\n\n      if (!existingMatch) {\n        const strictParseParams =\n          route.options.params?.parse ?? route.options.parseParams\n\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams as Record<string, string>),\n            )\n          } catch (err: any) {\n            paramsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw paramsError\n            }\n          }\n        }\n      }\n\n      Object.assign(routeParams, strictParams)\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError,\n          __routeContext: undefined,\n          _nonReactive: {\n            loadPromise: createControlledPromise(),\n          },\n          __beforeLoadContext: undefined,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not calling from router.buildLocation\n\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n\n        if (route.options.context) {\n          const contextFnContext: RouteContextOptions<any, any, any, any> = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts: any) =>\n              this.navigate({ ...opts, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches,\n          }\n          // Get the route context\n          match.__routeContext =\n            route.options.context(contextFnContext) ?? undefined\n        }\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n    })\n\n    return matches\n  }\n\n  /** a cache for `parsePathname` */\n  private parsePathnameCache: ParsePathnameCache = createLRUCache(1000)\n\n  getMatchedRoutes: GetMatchRoutesFn = (\n    pathname: string,\n    routePathname: string | undefined,\n  ) => {\n    return getMatchedRoutes({\n      basepath: this.basepath,\n      pathname,\n      routePathname,\n      caseSensitive: this.options.caseSensitive,\n      routesByPath: this.routesByPath,\n      routesById: this.routesById,\n      flatRoutes: this.flatRoutes,\n      parseCache: this.parsePathnameCache,\n    })\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match._nonReactive.pendingTimeout)\n    match._nonReactive.pendingTimeout = undefined\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  /**\n   * Build the next ParsedLocation from navigation options without committing.\n   * Resolves `to`/`from`, params/search/hash/state, applies search validation\n   * and middlewares, and returns a stable, stringified location object.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/RouterType#buildlocation-method\n   */\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n    ): ParsedLocation => {\n      // We allow the caller to override the current location\n      const currentLocation = dest._fromLocation || this.latestLocation\n\n      const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n        _buildLocation: true,\n      })\n\n      // Now let's find the starting pathname\n      // This should default to the current location if no from is provided\n      const lastMatch = last(allCurrentLocationMatches)!\n\n      // check that from path exists in the current route tree\n      // do this check only on navigations during test or development\n      if (\n        dest.from &&\n        process.env.NODE_ENV !== 'production' &&\n        dest._isNavigate\n      ) {\n        const allFromMatches = this.getMatchedRoutes(\n          dest.from,\n          undefined,\n        ).matchedRoutes\n\n        const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n          return comparePaths(d.fullPath, dest.from!)\n        })\n\n        const matchedCurrent = findLast(allFromMatches, (d) => {\n          return comparePaths(d.fullPath, lastMatch.fullPath)\n        })\n\n        // for from to be invalid it shouldn't just be unmatched to currentLocation\n        // but the currentLocation should also be unmatched to from\n        if (!matchedFrom && !matchedCurrent) {\n          console.warn(`Could not find match for from: ${dest.from}`)\n        }\n      }\n\n      const defaultedFromPath =\n        dest.unsafeRelative === 'path'\n          ? currentLocation.pathname\n          : (dest.from ?? lastMatch.fullPath)\n\n      // ensure this includes the basePath if set\n      const fromPath = this.resolvePathWithBase(defaultedFromPath, '.')\n\n      // From search should always use the current location\n      const fromSearch = lastMatch.search\n      // Same with params. It can't hurt to provide as many as possible\n      const fromParams = { ...lastMatch.params }\n\n      // Resolve the next to\n      // ensure this includes the basePath if set\n      const nextTo = dest.to\n        ? this.resolvePathWithBase(fromPath, `${dest.to}`)\n        : this.resolvePathWithBase(fromPath, '.')\n\n      // Resolve the next params\n      const nextParams =\n        dest.params === false || dest.params === null\n          ? {}\n          : (dest.params ?? true) === true\n            ? fromParams\n            : Object.assign(\n                fromParams,\n                functionalUpdate(dest.params as any, fromParams),\n              )\n\n      // Interpolate the path first to get the actual resolved path, then match against that\n      const interpolatedNextTo = interpolatePath({\n        path: nextTo,\n        params: nextParams,\n        parseCache: this.parsePathnameCache,\n      }).interpolatedPath\n\n      const destRoutes = this.matchRoutes(interpolatedNextTo, undefined, {\n        _buildLocation: true,\n      }).map((d) => this.looseRoutesById[d.routeId]!)\n\n      // If there are any params, we need to stringify them\n      if (Object.keys(nextParams).length > 0) {\n        for (const route of destRoutes) {\n          const fn =\n            route.options.params?.stringify ?? route.options.stringifyParams\n          if (fn) {\n            Object.assign(nextParams, fn(nextParams))\n          }\n        }\n      }\n\n      const nextPathname = decodePath(\n        interpolatePath({\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          path: nextTo,\n          params: nextParams,\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache,\n        }).interpolatedPath,\n      )\n\n      // Resolve the next search\n      let nextSearch = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        const validatedSearch = {}\n        destRoutes.forEach((route) => {\n          if (route.options.validateSearch) {\n            try {\n              Object.assign(\n                validatedSearch,\n                validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...nextSearch,\n                }),\n              )\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n            }\n          }\n        })\n        nextSearch = validatedSearch\n      }\n\n      nextSearch = applySearchMiddleware({\n        search: nextSearch,\n        dest,\n        destRoutes,\n        _includeValidateSearch: opts._includeValidateSearch,\n      })\n\n      // Replace the equal deep\n      nextSearch = replaceEqualDeep(fromSearch, nextSearch)\n\n      // Stringify the next search\n      const searchStr = this.options.stringifySearch(nextSearch)\n\n      // Resolve the next hash\n      const hash =\n        dest.hash === true\n          ? currentLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, currentLocation.hash)\n            : undefined\n\n      // Resolve the next hash string\n      const hashStr = hash ? `#${hash}` : ''\n\n      // Resolve the next state\n      let nextState =\n        dest.state === true\n          ? currentLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, currentLocation.state)\n            : {}\n\n      // Replace the equal deep\n      nextState = replaceEqualDeep(currentLocation.state, nextState)\n\n      // Create the full path of the location\n      const fullPath = `${nextPathname}${searchStr}${hashStr}`\n\n      // Create the new href with full origin\n      const url = new URL(fullPath, this.origin)\n\n      // If a rewrite function is provided, use it to rewrite the URL\n      const rewrittenUrl = executeRewriteOutput(this.rewrite, url)\n\n      return {\n        publicHref:\n          rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n        href: fullPath,\n        url: rewrittenUrl.href,\n        pathname: nextPathname,\n        search: nextSearch,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(\n            this.basepath,\n            next.pathname,\n            {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            },\n            this.parsePathnameCache,\n          )\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from: _from, ...maskProps } = foundMask\n          maskedDest = {\n            from: opts.from,\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      if (maskedNext) {\n        next.maskedLocation = maskedNext\n      }\n\n      return next\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        from: opts.from,\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  /**\n   * Commit a previously built location to history (push/replace), optionally\n   * using view transitions and scroll restoration options.\n   */\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key', // TODO: Remove in v2 - use __TSR_key instead\n        '__TSR_key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl =\n      trimPathRight(this.latestLocation.href) === trimPathRight(next.href)\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                __TSR_key: undefined!,\n                key: undefined!, // TODO: Remove in v2 - use __TSR_key instead\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.publicHref,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  /** Convenience helper: build a location from options, then commit it. */\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n  }\n\n  /**\n   * Imperatively navigate using standard `NavigateOptions`. When `reloadDocument`\n   * or an absolute `href` is provided, performs a full document navigation.\n   * Otherwise, builds and commits a client-side location.\n   *\n   * @link https://tanstack.com/router/latest/docs/framework/react/api/router/NavigateOptionsType\n   */\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (!reloadDocument && href) {\n      try {\n        new URL(`${href}`)\n        reloadDocument = true\n      } catch {}\n    }\n\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = location.url\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return Promise.resolve()\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n      _isNavigate: true,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  beforeLoad = () => {\n    // Cancel any pending matches\n    this.cancelMatches()\n    this.updateLatestLocation()\n\n    if (this.isServer) {\n      // for SPAs on the initial load, this is handled by the Transitioner\n      const nextLocation = this.buildLocation({\n        to: this.latestLocation.pathname,\n        search: true,\n        params: true,\n        hash: true,\n        state: true,\n        _includeValidateSearch: true,\n      })\n\n      // Normalize URLs for comparison to handle encoding differences\n      // Browser history always stores encoded URLs while buildLocation may produce decoded URLs\n      const normalizeUrl = (url: string) => {\n        try {\n          return encodeURI(decodeURI(url))\n        } catch {\n          return url\n        }\n      }\n\n      if (\n        trimPath(normalizeUrl(this.latestLocation.href)) !==\n        trimPath(normalizeUrl(nextLocation.href))\n      ) {\n        let href = nextLocation.url\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, '') || '/'\n        }\n\n        throw redirect({ href })\n      }\n    }\n\n    // Match the routes\n    const pendingMatches = this.matchRoutes(this.latestLocation)\n\n    // Ingest the new matches\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'pending',\n      statusCode: 200,\n      isLoading: true,\n      location: this.latestLocation,\n      pendingMatches,\n      // If a cached moved to pendingMatches, remove it from cachedMatches\n      cachedMatches: s.cachedMatches.filter(\n        (d) => !pendingMatches.some((e) => e.id === d.id),\n      ),\n    }))\n  }\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    let redirect: AnyRedirect | undefined\n    let notFound: NotFoundError | undefined\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          this.beforeLoad()\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await loadMatches({\n            router: this,\n            sync: opts?.sync,\n            matches: this.state.pendingMatches as Array<AnyRouteMatch>,\n            location: next,\n            updateMatch: this.updateMatch,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              // Wrap batch in framework-specific transition wrapper (e.g., Solid's startTransition)\n              this.startTransition(() => {\n                this.startViewTransition(async () => {\n                  // this.viewTransitionPromise = createControlledPromise<true>()\n\n                  // Commit the pending matches. If a previous match was\n                  // removed, place it in the cachedMatches\n                  let exitingMatches: Array<AnyRouteMatch> = []\n                  let enteringMatches: Array<AnyRouteMatch> = []\n                  let stayingMatches: Array<AnyRouteMatch> = []\n\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches\n                      const newMatches = s.pendingMatches || s.matches\n\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id),\n                      )\n                      enteringMatches = newMatches.filter(\n                        (match) =>\n                          !previousMatches.some((d) => d.id === match.id),\n                      )\n                      stayingMatches = newMatches.filter((match) =>\n                        previousMatches.some((d) => d.id === match.id),\n                      )\n\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: undefined,\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter((d) => d.status !== 'error'),\n                        ],\n                      }\n                    })\n                    this.clearExpiredCache()\n                  })\n\n                  //\n                  ;(\n                    [\n                      [exitingMatches, 'onLeave'],\n                      [enteringMatches, 'onEnter'],\n                      [stayingMatches, 'onStay'],\n                    ] as const\n                  ).forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId]!.options[hook]?.(\n                        match,\n                      )\n                    })\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect.options,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.status\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    let newStatusCode: number | undefined = undefined\n    if (this.hasNotFoundMatch()) {\n      newStatusCode = 404\n    } else if (this.__store.state.matches.some((d) => d.status === 'error')) {\n      newStatusCode = 500\n    }\n    if (newStatusCode !== undefined) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: newStatusCode,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        if (resolvedViewTransitionTypes === false) {\n          fn()\n          return\n        }\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    const matchesKey = this.state.pendingMatches?.some((d) => d.id === id)\n      ? 'pendingMatches'\n      : this.state.matches.some((d) => d.id === id)\n        ? 'matches'\n        : this.state.cachedMatches.some((d) => d.id === id)\n          ? 'cachedMatches'\n          : ''\n\n    if (matchesKey) {\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) => (d.id === id ? updater(d) : d)),\n      }))\n    }\n  }\n\n  getMatch: GetMatchFn = (matchId: string) => {\n    const findFn = (d: { id: string }) => d.id === matchId\n    return (\n      this.state.cachedMatches.find(findFn) ??\n      this.state.pendingMatches?.find(findFn) ??\n      this.state.matches.find(findFn)\n    )\n  }\n\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(opts?.forcePending || d.status === 'error'\n            ? ({ status: 'pending', error: undefined } as const)\n            : undefined),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.shouldViewTransition = false\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (redirect: AnyRedirect): AnyRedirect => {\n    if (!redirect.options.href) {\n      const location = this.buildLocation(redirect.options)\n      let href = location.url\n      if (this.origin && href.startsWith(this.origin)) {\n        href = href.replace(this.origin, '') || '/'\n      }\n      redirect.options.href = location.href\n      redirect.headers.set('Location', href)\n    }\n    if (!redirect.headers.get('Location')) {\n      redirect.headers.set('Location', redirect.options.href)\n    }\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      const isError = d.status === 'error'\n      if (isError) return true\n\n      const gcEligible = Date.now() - d.updatedAt >= gcTime\n      return gcEligible\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = loadRouteChunk\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await loadMatches({\n        router: this,\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.options.reloadDocument) {\n          return undefined\n        }\n\n        return await this.preloadRoute({\n          ...err.options,\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = matchPathname(\n      this.basepath,\n      baseLocation.pathname,\n      {\n        ...opts,\n        to: next.pathname,\n      },\n      this.parsePathnameCache,\n    ) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match\n        : false\n    }\n\n    return match\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n  }\n\n  serverSsr?: ServerSsr\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\n/** Error thrown when search parameter validation fails. */\nexport class SearchParamError extends Error {}\n\n/** Error thrown when path parameter parsing/validation fails. */\nexport class PathParamError extends Error {}\n\nconst normalize = (str: string) =>\n  str.endsWith('/') && str.length > 1 ? str.slice(0, -1) : str\nfunction comparePaths(a: string, b: string) {\n  return normalize(a) === normalize(b)\n}\n\n/**\n * Lazily import a module function and forward arguments to it, retaining\n * parameter and return types for the selected export key.\n */\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\n/** Create an initial RouterState from a parsed location. */\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\n/**\n * Build the matched route chain and extract params for a pathname.\n * Falls back to the root route if no specific route is found.\n */\nexport function getMatchedRoutes<TRouteLike extends RouteLike>({\n  basepath = '/',\n  pathname,\n  routePathname,\n  caseSensitive,\n  routesByPath,\n  routesById,\n  flatRoutes,\n  parseCache,\n}: {\n  pathname: string\n  routePathname?: string\n  caseSensitive?: boolean\n  routesByPath: Record<string, TRouteLike>\n  routesById: Record<string, TRouteLike>\n  flatRoutes: Array<TRouteLike>\n  parseCache?: ParsePathnameCache\n  basepath?: string\n}) {\n  let routeParams: Record<string, string> = {}\n  const trimmedPath = trimPathRight(pathname)\n  const getMatchedParams = (route: TRouteLike) => {\n    const result = matchPathname(\n      basepath,\n      trimmedPath,\n      {\n        to: route.fullPath,\n        caseSensitive: route.options?.caseSensitive ?? caseSensitive,\n        // we need fuzzy matching for `notFoundMode: 'fuzzy'`\n        fuzzy: true,\n      },\n      parseCache,\n    )\n    return result\n  }\n\n  let foundRoute: TRouteLike | undefined =\n    routePathname !== undefined ? routesByPath[routePathname] : undefined\n  if (foundRoute) {\n    routeParams = getMatchedParams(foundRoute)!\n  } else {\n    // iterate over flatRoutes to find the best match\n    // if we find a fuzzy matching route, keep looking for a perfect fit\n    let fuzzyMatch:\n      | { foundRoute: TRouteLike; routeParams: Record<string, string> }\n      | undefined = undefined\n    for (const route of flatRoutes) {\n      const matchedParams = getMatchedParams(route)\n\n      if (matchedParams) {\n        if (\n          route.path !== '/' &&\n          (matchedParams as Record<string, string>)['**']\n        ) {\n          if (!fuzzyMatch) {\n            fuzzyMatch = { foundRoute: route, routeParams: matchedParams }\n          }\n        } else {\n          foundRoute = route\n          routeParams = matchedParams\n          break\n        }\n      }\n    }\n    // did not find a perfect fit, so take the fuzzy matching route if it exists\n    if (!foundRoute && fuzzyMatch) {\n      foundRoute = fuzzyMatch.foundRoute\n      routeParams = fuzzyMatch.routeParams\n    }\n  }\n\n  let routeCursor: TRouteLike = foundRoute || routesById[rootRouteId]!\n\n  const matchedRoutes: Array<TRouteLike> = [routeCursor]\n\n  while (routeCursor.parentRoute) {\n    routeCursor = routeCursor.parentRoute as TRouteLike\n    matchedRoutes.push(routeCursor)\n  }\n  matchedRoutes.reverse()\n\n  return { matchedRoutes, routeParams, foundRoute }\n}\n\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch,\n}: {\n  search: any\n  dest: BuildNextOptions\n  destRoutes: Array<AnyRoute>\n  _includeValidateSearch: boolean | undefined\n}) {\n  const allMiddlewares =\n    destRoutes.reduce(\n      (acc, route) => {\n        const middlewares: Array<SearchMiddleware<any>> = []\n\n        if ('search' in route.options) {\n          if (route.options.search?.middlewares) {\n            middlewares.push(...route.options.search.middlewares)\n          }\n        }\n        // TODO remove preSearchFilters and postSearchFilters in v2\n        else if (\n          route.options.preSearchFilters ||\n          route.options.postSearchFilters\n        ) {\n          const legacyMiddleware: SearchMiddleware<any> = ({\n            search,\n            next,\n          }) => {\n            let nextSearch = search\n\n            if (\n              'preSearchFilters' in route.options &&\n              route.options.preSearchFilters\n            ) {\n              nextSearch = route.options.preSearchFilters.reduce(\n                (prev, next) => next(prev),\n                search,\n              )\n            }\n\n            const result = next(nextSearch)\n\n            if (\n              'postSearchFilters' in route.options &&\n              route.options.postSearchFilters\n            ) {\n              return route.options.postSearchFilters.reduce(\n                (prev, next) => next(prev),\n                result,\n              )\n            }\n\n            return result\n          }\n          middlewares.push(legacyMiddleware)\n        }\n\n        if (_includeValidateSearch && route.options.validateSearch) {\n          const validate: SearchMiddleware<any> = ({ search, next }) => {\n            const result = next(search)\n            try {\n              const validatedSearch = {\n                ...result,\n                ...(validateSearch(route.options.validateSearch, result) ??\n                  undefined),\n              }\n              return validatedSearch\n            } catch {\n              // ignore errors here because they are already handled in matchRoutes\n              return result\n            }\n          }\n\n          middlewares.push(validate)\n        }\n\n        return acc.concat(middlewares)\n      },\n      [] as Array<SearchMiddleware<any>>,\n    ) ?? []\n\n  // the chain ends here since `next` is not called\n  const final: SearchMiddleware<any> = ({ search }) => {\n    if (!dest.search) {\n      return {}\n    }\n    if (dest.search === true) {\n      return search\n    }\n    return functionalUpdate(dest.search, search)\n  }\n\n  allMiddlewares.push(final)\n\n  const applyNext = (index: number, currentSearch: any): any => {\n    // no more middlewares left, return the current search\n    if (index >= allMiddlewares.length) {\n      return currentSearch\n    }\n\n    const middleware = allMiddlewares[index]!\n\n    const next = (newSearch: any): any => {\n      return applyNext(index + 1, newSearch)\n    }\n\n    return middleware({ search: currentSearch, next })\n  }\n\n  // Start applying middlewares\n  return applyNext(0, search)\n}\n"],"names":["redirect","opts","validateSearch","search","next"],"mappings":"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"}
\ No newline at end of file
